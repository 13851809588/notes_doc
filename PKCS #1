                                                                                                                                 
互联网工程任务组（IETF）K. Moriarty，编辑。
请求评论：8017 EMC Corporation
已淘汰：                                               B. Kaliski 3447 B
类别：信息性Verisign
ISSN：2070-1721年的J. Jonsson
                                                               子集AB
                                                                鲁施（A. Rusch）
                                                                     RSA
                                                           2016年十一月


          PKCS＃1：RSA密码规范规范版本2.2

抽象的

   本文件提供了实施的建议
   基于RSA算法的公共密钥密码学，涵盖
   密码基元，加密方案，签名方案
   附录和ASN.1语法，用于表示密钥和标识
   该计划。

   本文档代表RSA对PKCS＃1 v2.2的重新发布
   实验室的公钥密码学标准（PKCS）系列。经过
   发布此RFC，更改控制权将转移到IETF。

   本文档也淘汰了RFC 3447。

该备忘录的状态

   本文档不是Internet Standards Track规范。这是
   已发布，仅供参考。

   本文档是Internet工程任务组的产品
   （IETF）。它代表了IETF社区的共识。它有
   受到公众审查，并已由
   互联网工程指导小组（IESG）。并非所有文件
   由IESG批准的任何级别的Internet的候选人
   标准; 请参阅RFC 7841的第2节。

   有关本文档当前状态的信息，任何勘误，
   以及有关如何提供反馈的信息，请访问
   http://www.rfc-editor.org/info/rfc8017。









Moriarty等。信息性[第1页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


版权声明

   版权所有（c）2016 IETF Trust和被认定为
   文档作者。版权所有。

   本文档受BCP 78和IETF信托法律的约束
   有关IETF文件的规定
   （http://trustee.ietf.org/license-info）自生效之日起生效
   本文档的发布。请查看这些文件
   小心，因为它们描述了您在尊重方面的权利和限制
   这份文件。从本文档中提取的代码组件必须
   包括简化的BSD许可文本，如第4.e节中所述
   信托法律条款，并且不提供任何担保，因为
   在简化的BSD许可证中进行了说明。



1。介绍

   本文件提供了实施的建议
   基于RSA算法[ RSA ]的公共密钥密码学，涵盖
   以下几个方面：

   o密码原语

   o加密方案

   o带附录的签名方案

   o ASN.1语法，用于表示密钥和标识方案

   这些建议旨在在以下范围内普遍应用
   计算机和通信系统，因此包括相当数量
   的灵活性。预计基于
   这些规范可能包括其他约束。这
   建议旨在与IEEE标准兼容
   1363 [ IEEE1363 ]，IEEE 1363a [ IEEE1363A ]和ANSI X9.44 [ ANSIX944 ]。

   本文档取代PKCS＃1版本2.1 [ RFC3447 ]，但包括
   兼容技术。

   本文档的组织如下：

   o  第1节是介绍。

   o  第2节定义了本文档中使用的一些符号。



Moriarty等。信息性[第4页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   o  第3节定义了RSA公钥和私钥类型。

   o第4节和第5节定义了几个基本要素，或基本数学
      操作。数据转换原语在第4节中，以及
      密码原语（加密，解密和签名-
      验证）在第5节中。

   O部分6，7和8处理的加密和签名
      本文档中的方案。  第6节给出了概述。沿着
      使用PKCS＃1 v1.5中的方法，第7节定义了
      最优非对称加密填充的加密方案
      （OAEP）[ OAEP ]，第8节定义了一个签名方案，
      基于概率签名方案（PSS）的附录
      [ RSARABIN ] [ PSS ]。

   o  第9节定义了签名方案的编码方法
      在第8节中。

   o  附录A为第3节中定义的密钥以及第7节和第8节中的方案定义了ASN.1语法
      。

   o  附录B定义了哈希函数和掩码生成
      本文档中使用的功能（MGF），包括ASN.1语法，用于
      技术。

   o  附录C给出了ASN.1模块。

   o附录D和E概述了PKCS＃1和
      提供有关公钥密码学的一般信息
      标准。

   本文档代表PKCS＃1 v2.2的重新发布[ PKCS1_22 ]
   来自RSA实验室的公钥密码学标准（PKCS）
   系列。

1.1。需求语言

   关键字“必须”，“必须”，“必须”，“应”，“应禁止”，
   “ SHOULD”，“ SHOULD NOT”，“推荐”，“ MAY”和“ OPTIONAL”在此
   文档将按照[ RFC2119 ]中的说明进行解释。











Moriarty等。信息性[第5页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


2。符号

   本文档中的符号包括：

      c密文代表，0到之间的整数
                     n-1

      C密文，八位字节串

      d RSA私有指数

      d_i附加因子r_i的CRT指数，
                     一个正整数，使得

                       e * d_i == 1（mod（r_i-1）），i = 3，...，u

      dP p的CRT指数，一个正整数，使得

                       e * dP == 1（mod（p-1））

      dQ q的CRT指数，一个正整数，使得

                       e * dQ == 1（mod（q-1））

      RSA公共指数

      EM编码的消息，一个八位字节字符串

      emBits（预期的）长度，以编码后的消息EM的位为单位

      emLen（预期的）长度，以八位位组的形式编码的消息
                     电磁

      GCD（。，。）两个非负整数的最大公约数

      哈希哈希函数

      hLen输出长度（以八位字节为单位）的哈希函数Hash

      k长度，以RSA模数n的八位字节为单位

      K RSA私钥

      l可选的RSAES-OAEP标签，一个八位字节字符串

      非负数列表的LCM（。，...，。）最小公倍数
                     整数




Moriarty等。信息性[第6页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


      m消息代表，0到之间的整数
                     n-1

      M消息，一个八位字节串

      掩码MGF输出，一个八位字节串

      maskLen（预期的）八位字节串掩码的长度

      MGF遮罩生成功能

      从其生成掩码的mgfSeed种子，一个八位位组字符串

      消息M的八位位组中的mLen长度

      n RSA模数，n = r_1 * r_2 * ... * r_u，u> = 2

      （n，e）RSA公钥

      p，q RSA模数n的前两个素数

      qInv CRT系数，小于
                     p使得q * qInv == 1（mod p）

      RSA模数n的r_i素因子，包括
                     r_1 = p，r_2 = q，以及其他因素（如果有）

      s签名代表，0到之间的整数
                     n-1

      S签名，八位字节字符串

      长度以EMSA-PSS盐的八位字节为单位

      t_i附加质数因子r_i的CRT系数a
                     小于r_i的正整数，使得

                       r_1 * r_2 * ... * r_（i-1）* t_i == 1（mod r_i），

                     i = 3，...，u

      u RSA模数的素数个数，u> = 2

      xa非负整数

      X与x对应的八位字节字符串

      xLen（预期的）八位位组字符串的长度X



Moriarty等。信息性[第7页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


      八位字节的十六进制表示形式的0x指示符
                     或八位位组字符串：“ 0x48”表示带有的八位位组
                     十六进制值48; “（0x）48 09 0e”表示
                     十六进制的三个连续八位字节的字符串
                     值分别为48、09和0e

      \ lambda（n）LCM（r_1-1，r_2-1，...，r_u-1）

      \ xor两个八位位组字符串的按位异或

      \ ceil（。）天花板函数；\ ceil（x）是最小的整数
                     大于或等于实数x

      || 级联运算符

      ==同余符号；a == b（mod n）表示
                     整数n除以整数a-b

   注意：中国余数定理（CRT）可以应用于非余数定理。
   递归以及递归方式。在本文档中，递归
   使用遵循Garner算法[ GARNER ]的方法。也可以看看第3.2节中的
   注1 。

3。按键类型

   在以下示例中定义的原语和方案中使用了两种密钥类型：
   本文档：RSA公钥和RSA私钥。一起，一个RSA
   公钥和RSA私钥形成RSA密钥对。

   该规范支持所谓的“多素数” RSA，其中
   模数可能有两个以上的主要因素。多重收益
   原始RSA的解密成本较低，
   签名原语，前提是使用了CRT。更好的
   性能可以在单处理器平台上实现，但是
   在更大范围的多处理器平台上，其中模块化
   所涉及的取幂可以并行进行。

   有关多素数如何影响RSA安全性的讨论
   密码系统，请读者参阅[ SILVERMAN ]。

3.1。RSA公钥

   就本文档而言，RSA公钥包含两个
   成分：

         n RSA模数，一个正整数
         RSA公共指数，一个正整数




Moriarty等。信息性[第8页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   在有效的RSA公钥中，RSA模数n是u的乘积
   独特的奇数素数r_i，i = 1，2，...，u，其中u> = 2，和RSA
   公共指数e是3到n-1之间的整数，满足
   GCD（e，\ lambda（n））= 1，其中\ lambda（n）= LCM（r_1-...，r_u-1）。
   按照惯例，前两个素数r_1和r_2也可以表示为p
   和q分别。

   在两个之间交换RSA公钥的推荐语法
   实现在附录A.1.1中给出; 一个实现的
   内部表示可能会有所不同。

3.2。RSA私钥

   就本文档而言，RSA私钥可以具有以下任一特性：
   两种表示形式。

   1.第一个表示由对（n，d）组成，其中
       组件具有以下含义：

            n RSA模数，一个正整数
            d RSA私有指数，一个正整数

   2.第二种表示形式由五元组（p，q，dP，dQ，
       qInv）和一个（可能为空）三连串序列（r_i，d_i，
       t_i），i = 3，...，u，不在五元组中的每个素数一个，
       其中组件具有以下含义：

            p第一个因子，一个正整数
            q第二个因子，一个正整数
            dP第一个因子的CRT指数，正整数
            dQ第二个因子的CRT指数，一个正整数
            qInv（第一个）CRT系数，一个正整数
            r_i第i个因子，一个正整数
            d_i第i个因子的CRT指数，一个正整数
            t_i第i个因子的CRT系数，一个正整数

   在具有第一个表示形式的有效RSA私钥中，RSA
   模数n与相应的RSA公钥中的相同，并且为
   u个奇异质数r_i的乘积，i = 1、2，...，u，其中u
   > =2。RSA私有指数d是小于n的正整数
   满意的

      e * d == 1（mod \ lambda（n）），

   其中e是相应的RSA公共指数，\ lambda（n）是
   如3.1节所定义。





Moriarty等。信息性[第9页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   在具有第二个表示形式的有效RSA私钥中，两个
   因子p和q是RSA模数n的前两个素数
   （即r_1和r_2）；CRT指数dP和dQ为正
   分别小于p和q的整数满足

      e * dP == 1（mod（p-1））

      e * dQ == 1（mod（q-1）），

   CRT系数qInv是小于p的正整数
   满意的

      q * qInv == 1（mod p）。

   如果u> 2，表示将包含一个或多个三元组（r_i，
   d_i，t_i），i = 3，...，u。因子r_i是附加质数
   RSA模数的系数n。每个CRT指数d_i（i = 3，...，u）
   满足

      e * d_i == 1（mod（r_i-1））。

   每个CRT系数t_i（i = 3，...，u）为正整数，小于
   比r_i令人满意

      R_i * t_i == 1（mod r_i），

   其中R_i = r_1 * r_2 * ... * r_（i-1）。

   在两个之间交换RSA私钥的推荐语法
   实现，包括来自两种表示形式的组件，
   在附录A.1.2中给出; 实现的内部
   表示形式可能有所不同。

   笔记：

   1.这里的CRT系数的定义和公式
       在第5节的原语中使用它们通常遵循Garner的
       算法[ GARNER ]（另请参见[手册]中的算法14.71 ）。
       但是，为了与RSA表示兼容
       PKCS＃1 v2.0和早期版本中的私钥，
       与其余质数相比，p和q取反。因此，
       第一个CRT系数qInv定义为q的倒数
       mod p，而不是R_1 mod r_2的倒数，即
       p mod q。

   2. Quisquater和Couvreur [ FASTDEC ]观察到了
       将CRT应用于RSA操作。




Moriarty等。信息性[第10页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


4。数据转换原语

   在定义的方案中使用了两个数据转换原语
   这个文件：

   I2OSP-八进制字符串整数

   OS2IP-八进制字符串到整数基元

   就本文档而言，并与ASN.1语法一致，
   八位位组字符串是八位位组（八位字节）的有序序列。
   该序列从第一个（通常是最左侧）到最后一个索引
   （最右边）。为了与整数进行转换，
   在以下情况下，第一个八位位组被认为是最重要的
   转换原语。

4.1。I2OSP

   I2OSP将非负整数转换为a的八位字节串
   指定的长度。

   I2OSP（x，xLen）

   输入：

      x要转换的非负整数

      xLen生成的八位位组字符串的预期长度

   输出：

         X长度为xLen的相应八位字节串

   错误：“整数太大”

   脚步：

      1.如果x> = 256 ^ xLen，则输出“整数太大”并停止。

      2.将整数x以其唯一的xLen-数字表示形式写在
          基本256：

             x = x_（xLen-1）256 ^（xLen-1）+ x_（xLen-2）256 ^（xLen-2）+ ...
             + x_1 256 + x_0，

          其中0 <= x_i <256（请注意一个或多个前导数字
          如果x小于256 ^（xLen-1））将为零。




Moriarty等。信息性[第11页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


      3.令八位位组X_i具有1 <= i的整数值x_（xLen-i）
          <= xLen。输出八位字节字符串

             X = X_1 X_2 ... X_xLen。

4.2。OS2IP

   OS2IP将八位字节字符串转换为非负整数。

   OS2IP（X）

   输入：要转换的X个八位字节字符串

   输出：x对应的非负整数

   脚步：

      1.令X_1 X_2 ... X_xLen为X的第一个八位字节，从最后到最后，
          并将x_（xLen-i）设为1的八位位组X_i的整数值
          <=我<= xLen。

      2.令x = x_（xLen-1）256 ^（xLen-1）+ x_（xLen-2）256 ^（xLen-2）+
          ... + x_1 256 + x_0。

      3.输出x。

5。密码基元

   密码原语是基本的数学运算，
   可以建立加密方案。它们旨在
   以硬件或软件模块的形式实现，而不是
   旨在提供除方案外的安全性。

   本文档中指定了四种原始类型，它们的组织方式如下：
   对：加密和解密；以及签名和验证。

   原语的规范假设某些条件
   输入满足需求，特别是RSA公钥和私钥
   是有效的。

5.1。加密和解密原语

   加密原语从
   消息代表在公共密钥的控制下，以及
   解密原语从
   密文代表在相应的控制下
   私钥。




Moriarty等。信息性[第12页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   一对加密和解密原语用于
   本文档中定义的加密方案，在此处指定：
   RSA加密基元（RSAEP）/ RSA解密基元（RSADP）。
   RSAEP和RSADP涉及相同的数学运算，
   不同的按键作为输入。此处定义的原语与
   使用RSA（IFEP-RSA）的整数分解加密原语/
   使用RSA（IFDP-RSA）进行整数分解解密原语
   IEEE 1363 [ IEEE1363 ]（除了对多质数RSA的支持
   已添加），并且与PKCS＃1 v1.5兼容。

   每个基元中的主要数学运算是求幂。

5.1.1。RSAEP

   RSAEP（（n，e），m）

   输入：

         （n，e）RSA公钥

         m消息代表，0到n-1之间的整数

   输出：c密文代表，0到n-1之间的整数

   错误：“消息代表超出范围”

   假设：RSA公钥（n，e）有效

   脚步：

      1.如果消息代表m不在0到n-1之间，
          输出“消息代表超出范围”并停止。

      2.令c = m ^ e mod n。

      3.输出c。

5.1.2。RSADP

   RSADP（K，c）

   输入：

         K个RSA私钥，其中K具有以下格式之一：

         +一对（n，d）





Moriarty等。信息性[第13页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


         +五元组（p，q，dP，dQ，qInv）和可能为空
            三元组的序列（r_i，d_i，t_i），i = 3，...，u

         c密文代表，0到n-1之间的整数

   输出：m个消息代表，0到n-1之间的整数

   错误：“密文代表超出范围”

   假设：RSA私钥K有效

   脚步：

      1.如果密文代表c不在0到n-1之间
          输出“密文代表超出范围”并停止。

      2.消息代表m如下计算。

          一种。如果使用K的第一个形式（n，d），则令m = c ^ d mod n。

          b。如果第二种形式（p，q，dP，dQ，qInv）和（r_i，d_i，
              使用K的t_i），操作如下：

              一世。令m_1 = c ^ dP mod p和m_2 = c ^ dQ mod q。

              ii。如果u> 2，令m_i = c ^（d_i）mod r_i，i = 3，...，u。

              iii。令h =（m_1-m_2）* qInv mod p。

              iv。令m = m_2 + q * h。

              v。如果u> 2，令R = r_1，而让i = 3，则u

                   1.令R = R * r_（i-1）。

                   2.令h =（m_i-m）* t_i mod r_i。

                   3.令m = m + R * h。

      3.输出m。

   注意：只要可以将第2.b步重写为一个循环，
   反转p和q的顺序。为了与PKCS＃1 v2.0保持一致，
   但是，前两个质数p和q与
   其他素数。






Moriarty等。信息性[第14页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


5.2。签名和验证原语

   签名原语从
   消息代表在私钥的控制下，以及
   验证原语从
   签名代表在相应的控制下
   公钥。一对签名和验证原语是
   在本文档中定义的签名方案中使用，并且
   在此处指定：RSA签名基元，版本1（RSASP1）/ RSA
   验证基元，版本1（RSAVP1）。

   此处定义的原语与整数分解相同
   使用RSA版本1（IFSP-RSA1）/整数的签名基元
   使用RSA版本1（IFVP-RSA1）的因式分解验证原语
   在IEEE 1363 [ IEEE1363 ]中（除了对多素RSA的支持
   已添加），并且与PKCS＃1 v1.5兼容。

   每个原语中的主要数学运算是求幂，
   如5.1节的加密和解密原语中所述。
   RSASP1和RSAVP1与RSADP和RSAEP相同，除了
   输入和输出参数的名称；他们被尊为
   它们用于不同的目的。

5.2.1。RSASP1

   RSASP1（K，m）

   输入：

      K个RSA私钥，其中K具有以下格式之一：
               -一对（n，d）
               -五元组（p，q，dP，dQ，qInv）和a（可能为空）
                 三元组的序列（r_i，d_i，t_i），i = 3，...，u
      m消息代表，0到n-1之间的整数


   输出：

      s签名代表，0到n-1之间的整数

   错误：“消息代表超出范围”

   假设：RSA私钥K有效








Moriarty等。信息性[第15页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   脚步：

      1.如果消息代表m不在0到n-1之间，
          输出“消息代表超出范围”并停止。

      2.签名代表s的计算如下。

          一种。如果使用K的第一个形式（n，d），则s = m ^ d mod n。

          b。如果第二种形式（p，q，dP，dQ，qInv）和（r_i，d_i，
              使用K的t_i），操作如下：

              1.令s_1 = m ^ dP mod p和s_2 = m ^ dQ mod q。

              2.如果u> 2，令s_i = m ^（d_i）mod r_i，则i = 3，...，u。

              3.令h =（s_1-s_2）* qInv mod p。

              4.令s = s_2 + q * h。

              5.如果u> 2，令R = r_1，对于i = 3，则做u

                  一种。令R = R * r_（i-1）。

                  b。令h =（s_i-s）* t_i mod r_i。

                  C。令s = s + R * h。

      3.输出s。

   注意：只要可以将第2.b步重写为一个循环，
   反转p和q的顺序。为了与PKCS＃1 v2.0保持一致，
   但是，前两个质数p和q与
   其他素数。

5.2.2。RSAVP1

   RSAVP1（（n，e），s）

   输入：

         （n，e）RSA公钥

         s签名代表，0到n-1之间的整数







Moriarty等。信息性[第16页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   输出：

         m消息代表，0到n-1之间的整数

   错误：“签名代表超出范围”

   假设：RSA公钥（n，e）有效

   脚步：

      1.如果签名代表s不在0到n-1之间，
          输出“签名代表超出范围”并停止。

      2.令m = s ^ e mod n。

      3.输出m。

6。计划概述

   方案结合了加密原语和其他技术，
   实现特定的安全目标。两种类型的方案是
   本文档中指定的内容：加密方案和签名方案
   附附录。

   本文档中指定的方案在范围上受到限制，因为
   它们的操作仅包含使用RSA处理数据的步骤
   公钥或私钥，并且不包括获取或获取密码的步骤
   验证密钥。因此，除了方案操作之外，
   应用程序通常将包括密钥管理操作，通过这些操作
   各方可以为方案选择RSA公钥和私钥
   手术。具体的其他操作和其他详细信息是
   超出本文档的范围。

   与密码原语一样（第5节），
   方案操作的规范假设某些条件
   输入满足需求，特别是RSA公钥和私钥
   是有效的。因此，实现的行为是不确定的
   当密钥无效时。这种不确定行为的影响
   取决于应用程序。解决密钥的可能方法
   验证包括应用程序的显式密钥验证；钥匙
   公钥基础设施内的验证；和分配
   使用无效方密钥执行的操作的责任
   谁生成了密钥。

   通常的良好加密做法是使用给定的RSA密钥
   配对只有一种方案。这就避免了存在漏洞的风险。
   一种方案可能会损害另一种方案的安全性，并且可能是
   对维持可证明的安全性至关重要。而RSAES-PKCS1-v1_5



Moriarty等。信息性[第17页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   （第7.2节）和RSASSA-PKCS1-v1_5（第8.2节）传统上具有
   被一起雇用而没有任何已知的不良互动（事实上，
   这是PKCS＃1 v1.5引入的模型，例如
   不建议将RSA密钥对用于新应用程序。

   说明与使用RSA密钥对有关的风险
   在多个方案中，假设在两个方案中都使用了RSA密钥对
   RSAES-OAEP（第7.1节）和RSAES-PKCS1-v1_5。虽然RSAES-OAEP
   本身会抵抗攻击，对手可能会利用
   执行RSAES-PKCS1-v1_5的弱点来恢复
   使用任何一种方案加密的邮件。再举一个例子，假设
   RSASSA-PSS（第8.1节）和
   RSASSA-PKCS1-v1_5。那么RSASSA-PSS的安全证明就不会
   更长的时间就足够了，因为证明不占
   可能使用第二种方案生成签名的可能性。
   如果在以下情况下使用RSA密钥对，则可能会采用类似的考虑因素：
   这里定义的方案之一，以及其他地方定义的变体。

7。加密方案

   就本文档而言，加密方案包括
   加密操作和解密操作，其中
   加密操作从带有以下内容的消息中产生密文：
   收件人的RSA公钥，解密操作将恢复
   来自密文的消息，以及收件人的相应RSA
   私钥。

   可以在多种应用中采用加密方案。一个
   典型的应用是密钥建立协议，其中
   邮件包含要从一个人那里秘密发送的关键材料
   参加另一个聚会。例如，PKCS＃7 [ RFC2315 ]采用了
   协议，以将内容加密密钥从发送方传递到
   接受者; 这里定义的加密方案将是合适的密钥-
   在这种情况下的加密算法。

   本文档中指定了两种加密方案：RSAES-OAEP和
   RSAES-PKCS1-v1_5。新的要求支持RSAES-OAEP
   应用；仅出于兼容目的提供了RSAES-PKCS1-v1_5
   与现有的应用程序。

   此处给出的加密方案遵循类似于以下内容的通用模型
   IEEE 1363 [ IEEE1363 ]中采用的方法，将加密和
   解密原语和用于加密的编码方法。这
   加密操作将消息编码操作应用于消息
   产生编码的消息，然后将其转换为整数
   消息代表。加密原语应用于
   产生密文的消息代表。扭转这个，
   解密操作将解密原语应用于



Moriarty等。信息性[第18页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   密文以恢复消息代表，然后
   转换为八位字节字符串编码的消息。消息解码
   将操作应用于编码后的消息以恢复该消息
   并验证解密的正确性。

   为了避免与错误处理方式相关的实施缺陷
   在解码操作中处理（请参阅[ BLEICHENBACHER ]和
   [ MANGER ]），用于RSAES-OAEP和
   RSAES-PKCS1-v1_5嵌入各自的规范中
   加密方案，而不是在单独的规范中定义。
   两种加密方案都与相应的方案兼容
   在PKCS＃1 v2.1中。

7.1。RSAES-OAEP

   RSAES-OAEP结合了RSAEP和RSADP原语（第5.1.1节）
   和5.1.2）使用EME-OAEP编码方法（第2步中的步骤2
   7.1.1节和7.1.2节中的步骤3 ）。EME-OAEP基于
   Bellare和Rogaway的最佳非对称加密方案[ OAEP ]。
   它与整数分解加密方案兼容
   （IFES）在IEEE 1363 [ IEEE1363 ]中定义，其中加密和
   解密原语是IFEP-RSA和IFDP-RSA以及消息
   编码方法是EME-OAEP。RSAES-OAEP可以对以下消息进行操作
   长度最大为k-2hLen -2个八位位组，其中hLen是
   基础哈希函数的输出，k是长度
   收件人的RSA模数的八位字节。

   假设以模n为模计算第e个根是不可行的，并且
   RSAES-OAEP中的掩码生成函数具有适当的属性，
   RSAES-OAEP在语义上不受自适应选择密文的影响
   攻击。从某种意义上说，这种保证是可以证明的
   破坏RSAES-OAEP的难度可以直接与
   反转RSA函数，前提是生成掩码
   该功能被视为黑匣子或随机预言；参见[ FOPS ]和
   下面的注释有待进一步讨论。

   RSAES-OAEP的加密和解密操作都需要
   标签L的值作为输入。在此版本的PKCS＃1中，L为
   空字符串；标签的其他用途不在
   这个文件。有关相关的ASN.1语法，请参见附录A.2.1。

   通过选择散列函数和掩码对RSAES-OAEP进行参数化
   生成功能。对于给定的RSA，此选择应固定
   钥匙。建议的哈希和掩码生成函数在
   附录B。






Moriarty等。信息性[第19页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   注意：过去的结果有助于明确说明安全性属性
   OAEP编码方法[ OAEP ]的描述（大致描述的过程
   在7.1.1节的步骤2中）。背景如下。1994年，
   Bellare和Rogaway [ OAEP ]引入了一种安全概念，他们
   表示纯文本意识（PA94）。他们证明，如果
   确定性公钥加密原语（例如RSAEP）很难
   要在没有私钥的情况下进行反转，则基于OAEP的
   加密方案具有纯文本意识（在随机oracle模型中），
   大致意味着对手无法产生有效的密文
   而不实际“知道”底层明文。纯文本
   加密方案的意识与
   该方案对选择密文攻击的抵抗力。在这样的
   攻击时，对手就有机会向
   oracle模拟解密原语。使用的结果
   这些查询，对手试图解密挑战
   密文。

   但是，选择密文攻击有两种形式，即PA94
   表示仅针对其中之一的安全性。区别在于
   挑战者被允许后，对手可以做什么？
   密文。无关紧要的攻击场景（表示为CCA1）不会
   对手被攻击后，向解密预告片接受任何查询
   给定挑战密文，而自适应场景
   （表示为CCA2）（除了解密oracle拒绝
   挑战密文发布后将其解密）。1998年，
   贝拉雷（Bellare）和罗加威（Rogaway）以及德赛（Desai）和波切瓦（Pointcheval）[ PA98 ]
   提出了一个新的更强的纯文本意识（PA98）概念，
   确实暗示了针对CCA2的安全性。

   总而言之，有两个潜在的来源
   误解：PA94和PA98是等效概念，或者
   CCA1和CCA2是等效的概念。两种假设都会导致
   Bellare-Rogaway论文暗示了安全性的结论
   针对CCA2的OAEP，但不是。

   （脚注：可以公平地说PKCS＃1 v2.0引用了[ OAEP ]
   并声称“选择的密文攻击对
   无需RSAES-OAEP之类的支持纯文本的加密方案，而无需
   指定明文意识或所选密文的类型
   考虑到攻击。）

   从未证明OAEP可以抵御CCA2。事实上，Victor Shoup
   [ SHOUP ]已证明该证明不存在于
   一般情况。简而言之，Shoup展示了
   知道如何部分反转加密的CCA2方案
   原始但不知道如何将其完全反转
   能够打破计划。例如，可以想象一个攻击者
   如果她知道如何恢复所有的但能够打破RSAES-OAEP的人，



Moriarty等。信息性[第20页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   使用RSAEP加密的随机整数的前20个字节。这样的
   攻击者不需要完全能够反转RSAEP，因为她
   在她的攻击中不使用前20个八位位组。

   尽管如此，RSAES-OAEP仍然可以抵御CCA2的攻击，这一点得到了以下方面的证明：
   藤崎，冈本，Pointcheval和斯特恩[ FOPS ]之后不久
   宣布Shoup的结果。使用巧妙的晶格还原
   技术，他们设法展示了如何完全反转RSAEP
   原图像的足够大的部分。这个观察，
   结合证明OAEP对于CCA2是安全的，如果
   底层加密原语很难部分反转，填充
   Bellare和Rogaway关于RSAES-OAEP的证明之间的差距以及
   有些人可能认为他们证明了这一点。有些
   矛盾的是，我们因此被RSAEP表面上的弱点拯救了
   （即，整个逆可以从其中的一部分推导出）。

   但是，不幸的是，降低安全性对于
   具体参数。虽然证明成功地关联了
   对手A针对RSAES-OAEP的CCA2安全性对算法I
   反转RSA，我成功的概率只有大约
   \ epsilon ^ 2/2 ^ 18，其中\ epsilon是成功的概率
   一个。

   （注：在[ FOPS ]中，逆变器成功的概率为
   \ epsilon ^ 2 /4。附加因子1/2 ^ 16是由于八个
   在编码消息EM的开头固定零位，它们是
   在[ FOPS ]中考虑的OAEP变体中不存在。（必须是
   两次应用以反转RSA，并且每个应用程序对应一个
   因子1/2 ^ 8。））

   此外，I的运行时间约为t ^ 2，其中t为
   对手的运行时间。结果是我们不能
   排除了攻击RSAES-OAEP相当大的可能性
   比将RSA转换为具体参数更容易。不过，
   安全证明的存在提供了一定的保证，即
   RSAES-OAEP构造比诸如
   RSAES-PKCS1-v1_5。

   基于RSA密钥封装的混合加密方案
   机制（RSA-KEM）范式直接提供安全性的严格证明
   适用于具体参数；请参阅[ ISO18033 ]进行讨论。
   PKCS＃1的未来版本可能会基于此指定方案
   范例。








Moriarty等。信息性[第21页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


7.1.1。加密操作

   RSAES-OAEP-ENCRYPT（（n，e），M，L）

   选项：

      散列散列函数（hLen表示字节的长度，以八位字节为单位）
               哈希函数输出）
      MGF遮罩生成功能

   输入：

      （n，e）收件人的RSA公钥（k表示
               RSA模数的八位字节n）
      待加密的M消息，长度为mLen的八位字节串，
               其中mLen <= k-2hLen-2
      l与消息关联的可选标签；这
               L的默认值（如果未提供L的话）为空
               细绳

   输出：

      C密文，长度为k的八位字节串

   错误：“消息太长”；“标签太长”

   假设：RSA公钥（n，e）有效

   脚步：

      1.长度检查：

          一种。如果L的长度大于输入限制
              用于哈希函数（对于SHA-1，为2 ^ 61-1个八位位组），输出
              “标签过长”并停止。

          b。如果mLen> k-2hLen-2，则输出“消息太长”，然后
              停止。

      2. EME-OAEP编码（请参见下面的图1）：

          一种。如果未提供标签L，则使L为空字符串。
              令lHash = Hash（L），长度为hLen的八位字节串（请参见
              下面的注释）。

          b。生成由k-mLen-组成的填充字符串PS
              2hLen-2个零字节。PS的长度可以为零。




Moriarty等。信息性[第22页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


          C。连接lHash，PS，带有十六进制的单个八位位组
              值0x01，以及消息M组成的数据块DB
              长度k-hLen-1个八位位组

                 DB = lHash || PS || 0x01 || M.

          d。生成长度为hLen的随机八位字节字符串种子。

          e。令dbMask = MGF（seed，k-hLen-1）。

          F。令maskedDB = DB \ xor dbMask。

          G。设seedMask = MGF（maskedDB，hLen）。

          H。让maskedSeed =种子\ xor seedMask。

          一世。连接一个十六进制值为0x00的八位字节，
              maskedSeed和maskedDB形成一个编码消息EM
              长度k个八位位组为

                 EM = 0x00 || maskedSeed || maskedDB。

      3. RSA加密：

          一种。将编码的消息EM转换为整数消息
              m代表（请参阅第4.2节）：

                 m = OS2IP（EM）。

          b。将RSAEP加密原语（第5.1.1节）应用于
              RSA公钥（n，e）和消息代表m
              产生一个整数密文代表c：

                 c = RSAEP（（n，e），m）。

          C。将密文代表c转换为密文C
              长度为k个八位位组（请参阅第4.1节）：

                 C = I2OSP（c，k）。












Moriarty等。信息性[第23页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


      4.输出密文C。

      _________________________________________________________________

                                + ---------- + ------ +-+ ------- +
                           DB = | 哈希| PS | 01 | M |
                                + ---------- + ------ +-+ ------- +
                                               |
                     + ---------- + |
                     | 种子 |
                     + ---------- + |
                           | |
                           | -------> MGF ---> xor
                           | |
                  +-+ V |
                  | 00 | xor <----- MGF <----- |
                  +-+ | |
                    | | |
                    VVV
                  +-+ ---------- + ---------------------------- +
            EM = | 00 | maskedSeed | maskedDB |
                  +-+ ---------- + ---------------------------- +
      _________________________________________________________________

                   图1：EME-OAEP编码操作

   笔记：

   -lHash是可选标签L的哈希。

   -解码操作遵循相反的步骤以恢复M和
      验证lHash和PS。

   -如果L为空字符串，则对应的哈希值lHash具有
      以下十六进制表示形式，用于不同的选择
      杂凑：

      SHA-1：（0x）da39a3ee 5e6b4b0d 3255bfef 95601890 afd80709
      SHA-256：（0x）e3b0c442 98fc1c14 9afbf4c8 996fb924 27ae41e4 649b934c
                   a495991b 7852b855
      SHA-384：（0x）38b060a7 51ac9638 4cd9327e b1b1e36a 21fdb711 14be0743
                   4c0cc7bf 63f6e1da 274edebf e76f65fb d51ad2f1 4898b95b
      SHA-512：（0x）cf83e135 7eefb8bd f1542850 d66d8007 d620e405 0b5715dc
                   83f4a921 d36ce9ce 47d0d13c 5d85f2b0 ff8318d2 877eec2f
                   63b931bd 47417a81 a538327a f927da3e






Moriarty等。信息性[第24页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


7.1.2。解密操作

   RSAES-OAEP-DECRYPT（K，C，L）

   选项：

      散列散列函数（hLen表示字节的长度，以八位字节为单位）
               哈希函数输出）
      MGF遮罩生成功能

   输入：

      K个接收者的RSA私钥（k表示
               RSA模数n）个八位位组，其中k> = 2hLen + 2
      要解密的C密文，长度为k的八位字节串
      L可选标签，其与消息的关联为
               被验证；L的默认值（如果L不是）
               提供的是空字符串

   输出：

      M消息，长度为mLen的八位字节串，其中
               mLen <= k-2hLen-2

   错误：“解密错误”

   脚步：

      1.长度检查：

          一种。如果L的长度大于输入限制
              用于哈希函数（对于SHA-1，为2 ^ 61-1个八位位组），输出
              “解密错误”并停止。

          b。如果密文C的长度不是k个八位位组，则输出
              “解密错误”并停止。

          C。如果k <2hLen + 2，则输出“解密错误”并停止。

      2. RSA解密：

          一种。将密文C转换为整数密文
              代表c（请参阅第4.2节）：

                 c = OS2IP（C）。






Moriarty等。信息性[第25页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


          b。将RSADP解密原语（第5.1.2节）应用于
              RSA私钥K和密文代表c
              产生代表m的整数消息：

                 m ＝ RSADP（K，c）。

              如果RSADP输出“密文代表超出范围”
              （表示c> = n），输出“解密错误”并停止。

          C。将消息代表m转换为编码消息
              长度为k个八位位组的EM（请参阅第4.1节）：

                 EM = I2OSP（m，k）。

      3. EME-OAEP解码：

          一种。如果未提供标签L，则使L为空字符串。
              令lHash = Hash（L），长度为hLen的八位字节串（请参见7.1.1节中
              的注释）。

          b。将编码的消息EM分离为一个八位位组Y，
              长度为hLen的八位字节字符串maskedSeed和一个八位字节
              长度为k-hLen-1 as的字符串maskedDB

                 EM = Y || maskedSeed || maskedDB。

          C。设seedMask = MGF（maskedDB，hLen）。

          d。让seed = maskedSeed \ xor seedMask。

          e。令dbMask = MGF（seed，k-hLen-1）。

          F。令DB = maskedDB \ xor dbMask。

          G。将DB分成长度为hLen的八位字节字符串lHash'
              （可能为空）由八位字节组成的填充字符串PS
              十六进制值为0x00，消息M为

                 DB = lHash'|| PS || 0x01 || M.

              如果不存在十六进制值为0x01的八位位组，则
              如果lHash不等于lHash'，或者如果
              Y为非零，输出“解密错误”并停止。（看
              下面的注释。）







Moriarty等。信息性[第26页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


      4.输出消息M。

      注意：必须注意确保对手不能
      区分步骤3.g中的不同错误条件，是否
      错误消息或时间安排，更一般地说，是对手
      无法了解有关编码消息EM的部分信息。
      否则，对手可能会获得有用的信息
      关于密文C的解密，导致选择-
      密文攻击，例如Manger [ MANGER ]所观察到的一种。

7.2。RSAES-PKCS1-v1_5

   RSAES-PKCS1-v1_5结合了RSAEP和RSADP原语（本节
   5.1.1和5.1.2）采用EME-PKCS1-v1_5编码方法（第2步中的第2步）
   7.2.1节和7.2.2节中的步骤3 ）。从数学上讲
   等效于PKCS＃1 v1.5中的加密方案。
   RSAES-PKCS1-v1_5可以对最大长度为k-11的消息进行操作
   八位位组（k是RSA模数的八位位组长度），但要注意
   应采取措施避免由于以下原因对低指数RSA造成某些攻击：
   当长消息出现时，铜匠，富兰克林，帕塔林和赖特
   加密（请参阅下面注释中的第三个项目符号和[ LOWEXP ]；
   [ NEWATTACK ]包含改进的攻击）。作为一般规则，使用
   该方案用于加密任意消息，而不是
   随机生成的密钥，不推荐。

   可以生成有效的RSAES-PKCS1-v1_5密文，而无需
   以合理的概率了解相应的明文
   成功。可以在选定的密文中利用此功能
   攻击，如[ BLEICHENBACHER ]中所示。因此，如果RSAES-PKCS1-v1_5
   要使用时，应采取某些易于实施的对策
   为制止[ BLEICHENBACHER ]中的攻击而采取的措施。典型的
   例如，将结构添加到要编码的数据中，
   严格检查PKCS＃1 v1.5的一致性（以及其他冗余）
   在解密的邮件中，以及将错误消息合并到
   基于PKCS＃1 v1.5的客户端-服务器协议。这些都可以
   有效的对策，不涉及协议变更
   基于PKCS＃1 v1.5。请参阅[ BKS ]，以进一步讨论这些内容。
   和其他对策。最近显示，
   SSL / TLS握手协议[ RFC5246 ]的安全性，该协议使用
   RSAES-PKCS1-v1_5和某些对策，可以与
   RSA问题的变体；请参阅[ RSATLS ]进行讨论。

   注意：以下段落描述了一些安全建议
   有关使用RSAES-PKCS1-v1_5的信息。PKCS的建议
   包含＃1 v1.5以及由以下人员激发的新建议
   在过去的几年中，密码分析技术取得了长足的进步。





Moriarty等。信息性[第27页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   o建议在第2步的伪随机八位位组中
      分别为每种加密生成7.2.1节
      处理，特别是如果同一数据被输入到多个
      加密过程。Haastad的结果[ HAASTAD ]是一
      此建议的动机。

   o第7.2.1节的步骤2中的填充字符串PS至少为8
      八位字节长，这是公钥的安全条件
      使攻击者难以恢复数据的操作
      通过尝试所有可能的加密块。

   o伪随机八位位组还可以帮助阻止由于以下原因造成的攻击：
      铜匠等。[ LOWEXP ]（请参阅[ NEWATTACK ]以进行改进
      攻击的时间），当要加密的消息的大小为
      保持小。这种攻击在类似的情况下适用于低指数的RSA
      邮件使用相同的RSA公钥加密。更多的
      具体来说，在一种攻击方式下，当有两个输入
      RSAEP在很大一部分位（8/9）和低指数RSA上达成共识
      （e = 3）用于加密它们两者，可能
      通过攻击恢复两个输入。攻击的另一种味道
      当大密文成功解密单个密文时
      RSAEP输入的小数（2/3）是已知的。为了
      在典型的应用中，要加密的消息很短（例如，
      128位对称密钥），因此将无法获得足够的信息
      或两个消息之间的共同点以启用攻击。但是，如果
      长消息被加密，或者如果消息的一部分是已知的，
      那么攻击可能是一个问题。无论如何，RSAES-OAEP
      方案克服了攻击。

7.2.1。加密操作

   RSAES-PKCS1-V1_5-ENCRYPT（（n，e），M）

   输入：

      （n，e）收件人的RSA公钥（k表示
               模数的八位位组n）
      要加密的M消息，长度为八位字节的字符串
               mLen，其中mLen <= k-11

   输出：

      C密文，长度为k的八位字节串

   错误：“消息太长”






Moriarty等。信息性[页28]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   脚步：

      1.长度检查：如果mLen> k-11，则输出“消息过长”
          停下来

      2. EME-PKCS1-v1_5编码：

          一种。生成长度为k-mLen-3的八位字节串PS
              由伪随机生成的非零八位字节组成。
              PS的长度将至少为八个八位位组。

          b。连接PS，消息M和其他填充以形成
              长度为k个八位位组的编码消息EM为

                 EM = 0x00 || 0x02 || PS || 0x00 || M.

      3. RSA加密：

          一种。将编码的消息EM转换为整数消息
              m代表（请参阅第4.2节）：

                 m = OS2IP（EM）。

          b。将RSAEP加密原语（第5.1.1节）应用于
              RSA公钥（n，e）和消息代表m
              产生一个整数密文代表c：

                 c = RSAEP（（n，e），m）。

          C。将密文代表c转换为密文C
              长度为k个八位位组（请参阅第4.1节）：

                 C = I2OSP（c，k）。

      4.输出密文C。

7.2.2。解密操作

   RSAES-PKCS1-V1_5-DECRYPT（K，C）

   输入：

      K个收件人的RSA私钥
      要解密的C密文，长度为k的八位字节串，
               其中k是RSA模数n的八位字节长度






Moriarty等。信息性[第29页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   输出：

      M消息，长度为k-11的八位字节串

   错误：“解密错误”

   脚步：

      1.长度检查：如果密文C的长度不是k
          个八位位组（如果k <11），则输出“解密错误”并停止。

      2. RSA解密：

          一种。将密文C转换为整数密文
              代表c（请参阅第4.2节）：

                 c = OS2IP（C）。

          b。将RSADP解密原语（第5.1.2节）应用于
              RSA私钥（n，d）和密文
              代表c产生整数消息
              代表米：

                 m = RSADP（（n，d），c）。

              如果RSADP输出“密文代表超出范围”
              （表示c> = n），输出“解密错误”并停止。

          C。将消息代表m转换为编码消息
              长度为k个八位位组的EM（请参阅第4.1节）：

                 EM = I2OSP（m，k）。

      3. EME-PKCS1-v1_5解码：将编码后的消息EM分离为
          由非零字节和消息组成的字节字符串PS
          M为

             EM = 0x00 || 0x02 || PS || 0x00 || M.

          如果EM的第一个八位位组没有十六进制值0x00，
          如果EM的第二个八位字节没有十六进制值
          0x02，如果不存在十六进制值为0x00的八位字节，则为
          将PS与M分开，或者PS的长度小于8
          个八位位组，输出“解密错误”并停止。（请参阅注释
          以下。）

      4.输出M。




Moriarty等。信息性[第30页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


      注意：必须注意确保对手不能
      区分步骤3中的不同错误条件，是否
      错误消息或计时。否则，对手可能能够
      获得有关密文解密的有用信息
      C，导致强化版本的布雷肯巴赫的进攻
      [ BLEICHENBACHER ]; 比较马格的进攻[马格]。

8。签名方案及附录

   在本文档中，带有附录的签名方案
   由签名生成操作和签名组成
   验证操作，其中签名生成操作
   使用签名者的RSA私钥从邮件中生成签名，
   签名验证操作将在以下位置验证签名
   带有签名者的相应RSA公钥的消息。到
   验证使用这种类型的方案构造的签名，它是
   拥有消息本身是必要的。这样，签名方案
   带有附录的签名方案与带有消息的签名方案区别开来
   恢复，本文档不支持。

   带附录的签名方案可用于多种
   应用程序。例如，带有附录的签名方案
   这里定义的将是适用于X.509的签名算法
   证书[ ISO9594 ]。可以采用相关的签名方案
   在PKCS＃7 [ RFC2315 ]中，尽管出于技术原因，当前
   PKCS＃7的版本将哈希函数与签名方案分开，
   这与这里所做的不同；请参阅中的注释
   附录A.2.3有更多讨论。

   本文档中指定了两个带有附录的签名方案：
   RSASSA-PSS和RSASSA-PKCS1-v1_5。虽然没有攻击已知
   为了提高鲁棒性，针对RSASSA-PKCS1-v1_5
   在新应用中需要RSASSA-PSS。RSASSA-PKCS1-v1_5是
   仅包括与现有应用程序的兼容性。

   此处给出的带有附录的签名方案遵循通用模型
   与IEEE 1363 [ IEEE1363 ]中采用的相似，结合了签名
   以及带有签名编码方法的验证原语。
   签名生成操作应用消息编码
   对消息进行操作以生成编码后的消息，然后
   转换为整数消息代表。一个签名
   原语应用于消息代表以生成
   签名。反向进行签名验证操作
   将签名验证原语应用于签名以进行恢复
   消息代表，然后将其转换为八位字节串
   编码的消息。验证操作应用于消息
   以及编码后的消息，以确定它们是否一致。




Moriarty等。信息性[第31页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   如果编码方法是确定性的（例如EMSA-PKCS1-v1_5），则
   验证操作可以将消息编码操作应用于
   消息，然后将结果编码后的消息与
   先前派生的编码消息。如果有匹配项，
   签名被认为是有效的。如果方法是随机的（例如，
   EMSA-PSS），则验证操作通常更为复杂。
   例如，EMSA-PSS中的验证操作提取了
   随机盐和编码消息的哈希输出并进行检查
   哈希输出，盐和消息是否一致；
   就消息而言，哈希输出是确定性函数
   和盐。对于两个签名方案，其中附录定义了
   本文档中的签名生成和签名验证
   如果
   签名放置在消息之后。参见PKCS＃7 [ RFC2315 ]
   如果是RSASSA-PKCS1-v1_5，则为示例格式。

8.1。RSASSA-PSS

   RSASSA-PSS将RSASP1和RSAVP1原语与
   EMSA-PSS编码方法。与Integer兼容
   经附录修正的因式分解签名方案（IFSSA）
   IEEE 1363a [ IEEE1363A ]，其中的签名和验证
   原语是IFSP-RSA1和IFVP-RSA1，如IEEE 1363中所定义
   [ IEEE1363 ]，并且消息编码方法为EMSA4。EMSA4是
   比EMSA-PSS更具通用性，因为它作用于位串而不是
   而不是八位字节字符串。EMSA-PSS等同于EMSA4，仅限于
   操作数以及哈希值和盐值是
   八位位组字符串。

   RSASSA-PSS可以操作的消息长度为
   不受大量限制或限制，具体取决于
   EMSA-PSS编码方法基础的哈希函数。

   假设以模n为模计算第e个根是不可行的，并且
   EMSA-PSS中的哈希和掩码生成功能具有适当的功能
   属性，RSASSA-PSS提供安全签名。这种保证是
   从伪造签名的难度可以
   与反转RSA功能的难度直接相关，
   假设哈希和掩码生成函数被视为
   黑匣子或随机预言。安全证明中的界限是
   本质上是“紧密的”，这意味着成功的可能性和运行
   针对RSASSA-PSS进行最佳伪造的时间非常接近
   最佳RSA反演算法的相应参数；看
   [ RSARABIN ] [ PSSPROOF ] [ JONSSON ]进行进一步的讨论。

   与RSASSA-PKCS1-v1_5签名方案相反，哈希
   功能标识符未嵌入EMSA-PSS编码的消息中，
   因此，从理论上讲，对手可以用



Moriarty等。信息性[页32]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   与散列函数不同（可能更弱）的散列函数
   由签名者选择。因此，建议
   EMSA-PSS掩码生成函数应基于相同的哈希函数。
   以这种方式，整个编码后的消息将取决于
   哈希函数，对手很难替代
   不同于签名者预期的哈希函数。这
   哈希函数的匹配仅用于防止哈希
   函数替换，如果使用哈希函数则不需要
   替代是通过其他方式解决的（例如，验证者接受
   仅指定的哈希函数）。详见[ HASHID ]
   这些要点的讨论。RSASSA-PSS可证明的安全性
   不依赖掩码生成函数中的哈希函数
   与应用于消息的哈希函数相同。

   RSASSA-PSS在以下方面不同于其他基于RSA的签名方案
   它是概率性的，而不是确定性的，
   随机生成的盐值。盐值提高安全性
   通过提供“更严格的”安全性证明
   确定性替代方案，例如全域哈希（FDH）；看
   [ RSARABIN ]进行讨论。但是，随机性并不重要
   安全。在无法随机产生的情况下，
   可以使用固定值或序列号来代替
   由此产生的可证明安全性类似于FDH [ FDH ]。

8.1.1。签名生成操作

   RSASSA-PSS-SIGN（K，M）

   输入：

      K签名者的RSA私钥
      M消息要签名，八位字节字符串

   输出：

      S签名，长度为k的八位字节串，其中k是
               RSA模数n的八位字节长度

   错误：“消息太长；” “编码错误”

   脚步：

      1. EMSA-PSS编码：应用EMSA-PSS编码操作
          （第9.1.1节）将消息M生成编码后的消息
          长度为\ ceil（（modBits-1）/ 8）个八位位组的EM，使得该位
          整数OS2IP（EM）的长度（请参见第4.2节）最大为
          modBits-1，其中modBits是RSA的长度（以位为单位）
          模数n：



Moriarty等。信息性[Page 33]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


             EM = EMSA-PSS-ENCODE（M，modBits-1）。

          请注意，如果
          modBits-1可以被8整除，否则等于k。如果
          编码操作输出“消息太长”，输出
          “消息太长”并停止。如果编码操作
          输出“编码错误”，输出“编码错误”并停止。

      2. RSA签名：

          一种。将编码的消息EM转换为整数消息
              m代表（请参阅第4.2节）：

                 m = OS2IP（EM）。

          b。将RSASP1签名原语（第5.2.1节）应用于
              RSA私钥K和消息代表m
              产生一个整数签名代表s：

                 s = RSASP1（K，m）。

          C。将签名代表s转换为
              长度k个八位位组（请参阅第4.1节）：

                 S = I2OSP（s，k）。

      3.输出签名S。

8.1.2。签名验证操作

   RSASSA-PSS-VERIFY（（n，e），M，S）

   输入：

      （n，e）签名者的RSA公钥
      要验证其签名的M消息，八位字节字符串
      要验证的S签名，长度为k的八位字节串，
              其中k是RSA模数n的八位字节长度

   输出：“有效签名”或“无效签名”

   脚步：

      1.长度检查：如果签名S的长度不是k
          八位字节，输出“无效签名”并停止。






Moriarty等。信息性[页34]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


      2. RSA验证：

          一种。将签名S转换为整数签名
              代表（请参阅第4.2节）：

                 s = OS2IP（S）。

          b。将RSAVP1验证原语（第5.2.2节）应用于
              RSA公钥（n，e）和签名代表
              s产生代表m的整数消息：

                 m = RSAVP1（（n，e），s）。

              如果RSAVP1输出“签名代表超出范围”，
              输出“无效签名”并停止。

          C。将消息代表m转换为编码消息
              长度为emLen = \ ceil（（modBits-1）/ 8）个八位位组的EM，其中
              modBits是RSA模数n的以位为单位的长度（请参阅
              第4.1节）：

                 EM = I2OSP（m，emLen）。

              请注意，如果modBits-1为，则emLen将比k小1。
              可被8整除，否则等于k。如果I2OSP输出
              “整数太大”，输出“无效签名”并停止。

      3. EMSA-PSS验证：应用EMSA-PSS验证消息M和编码消息的
          操作（第9.1.2节）。
          消息EM以确定它们是否一致：

             结果= EMSA-PSS-VERIFY（M，EM，modBits-1）。

      4.如果结果=“一致”，则输出“有效签名”。
          否则，输出“无效签名”。

8.2。RSASSA-PKCS1-v1_5

   RSASSA-PKCS1-v1_5将RSASP1和RSAVP1原语与
   EMSA-PKCS1-v1_5编码方法。与IFSSA兼容
   IEEE 1363 [ IEEE1363 ]中定义的方案，其中签名和
   验证原语是IFSP-RSA1和IFVP-RSA1，并且消息
   编码方法为EMSA-PKCS1-v1_5（IEEE 1363中未定义）
   但在IEEE 1363a [ IEEE1363A ]中）。

   RSASSA-PKCS1-v1_5可以操作的消息长度为
   不受限制或受大量限制，具体取决于
   基于EMSA-PKCS1-v1_5方法基础的哈希函数。



Moriarty等。信息性[页35]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   假设以模n为模计算第e个根是不可行的，并且
   EMSA-PKCS1-v1_5中的哈希函数具有适当的属性，
   推测RSASSA-PKCS1-v1_5提供了安全的签名。更多的
   确切地说，在不知道RSA私钥的情况下伪造签名是
   推测在计算上是不可行的。另外，在编码中
   方法EMSA-PKCS1-v1_5，则将哈希函数标识符嵌入到
   编码。由于此功能，一个对手试图找到一个
   与先前签名的邮件具有相同签名的邮件必须
   查找正在使用的特定哈希函数的冲突；攻击
   与签名者选择的哈希函数不同的哈希函数不是
   对对手有用。请参阅[ HASHID ]进行进一步的讨论。

   注意：如PKCS＃1 v1.5中所述，EMSA-PKCS1-v1_5编码方法
   具有将编码后的消息转换为整数的属性
   消息代表，保证很大并且至少
   有点“随机”。这样可以防止由
   Desmedt和Odlyzko [所选择的]乘法关系
   消息代表之间的开发是通过考虑
   将消息代表分成一组较小的值（例如，一组
   小素数）。Coron，Naccache和Stern [ PADDING ]表明，
   这种类型的攻击的更强大形式可能会非常有效地抵御
   ISO / IEC 9796-2签名方案的某些实例。他们也
   分析了针对此类攻击的复杂性
   EMSA-PKCS1-v1_5编码方法，得出的结论是会发动攻击
   不切实际，需要比碰撞搜索更多的操作
   底层哈希函数（即，超过2 ^ 80个操作）。
   Coppersmith，Halevi和Jutla [伪造]随后扩展了Coron
   等人的攻击，以破坏ISO / IEC 9796-1签名方案
   邮件恢复。各种攻击说明了
   仔细构造RSA签名原语的输入，
   特别是在具有消息恢复功能的签名方案中。
   因此，EMSA-PKCS-v1_5编码方法明确包含
   散列运算，不适用于带有消息的签名方案
   恢复。而且，虽然没有针对
   EMSA-PKCS-v1_5编码方法，逐步过渡到EMSA-PSS
   建议作为未来发展的预防措施。

8.2.1。签名生成操作

   RSASSA-PKCS1-V1_5-SIGN（K，M）

   输入：

      K签名者的RSA私钥
      M消息要签名，八位字节字符串






Moriarty等。信息性[页36]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   输出：

      S签名，长度为k的八位字节串，其中k是
               RSA模数n的八位字节长度

   错误：“消息太长”；“ RSA模数太短”

   脚步：

      1. EMSA-PKCS1-v1_5编码：应用EMSA-PKCS1-v1_5编码对消息M的
          操作（第9.2节）以产生编码
          长度为k个八位位组的消息EM：

             EM = EMSA-PKCS1-V1_5-ENCODE（M，k）。

          如果编码操作输出“消息太长”，则输出
          “消息太长”并停止。如果编码操作
          输出“预期的编码消息长度太短”，输出
          “ RSA模数太短”并停止。

      2. RSA签名：

          一种。将编码的消息EM转换为整数消息
              m代表（请参阅第4.2节）：

                 m = OS2IP（EM）。

          b。将RSASP1签名原语（第5.2.1节）应用于
              RSA私钥K和消息代表m
              产生一个整数签名代表s：

                 s = RSASP1（K，m）。

          C。将签名代表s转换为
              长度k个八位位组（请参阅第4.1节）：

                 S = I2OSP（s，k）。

      3.输出签名S。

8.2.2。签名验证操作

   RSASSA-PKCS1-V1_5-VERIFY（（n，e），M，S）

   输入：

      （n，e）签名者的RSA公钥
      要验证其签名的M消息，八位字节字符串



Moriarty等。信息性[页37]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


      要验证的S签名，长度为k的八位字节串，
              其中k是RSA模数n的八位字节长度

   输出“有效签名”或“无效签名”

   错误：“消息太长”；“ RSA模数太短”

   脚步：

      1.长度检查：如果签名S的长度不是k
          八位字节，输出“无效签名”并停止。

      2. RSA验证：

          一种。将签名S转换为整数签名
              代表（请参阅第4.2节）：

                 s = OS2IP（S）。

          b。将RSAVP1验证原语（第5.2.2节）应用于
              RSA公钥（n，e）和签名代表
              s产生代表m的整数消息：

                 m = RSAVP1（（n，e），s）。

              如果RSAVP1输出“签名代表超出范围”，
              输出“无效签名”并停止。

          C。将消息代表m转换为编码消息
              长度为k个八位位组的EM（请参阅第4.1节）：

                 EM = I2OSP（m，k）。

              如果I2OSP输出“整数太大”，则输出“无效”
              签名”并停止。

      3. EMSA-PKCS1-v1_5编码：应用EMSA-PKCS1-v1_5编码对消息M的
          操作（第9.2节）以产生第二个消息。
          长度为k个八位位组的编码消息EM'：

             EM'= EMSA-PKCS1-V1_5-ENCODE（M，k）。

          如果编码操作输出“消息太长”，则输出
          “消息太长”并停止。如果编码操作
          输出“预期的编码消息长度太短”，输出
          “ RSA模数太短”并停止。





Moriarty等。信息性[Page 38]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


      4.比较编码的消息EM和第二个编码的消息
          EM'。如果相同，则输出“有效签名”；
          否则，输出“无效签名”。

      注意：另一种实现签名验证的方法
      操作是应用“解码”操作（未在
      此文档）到已编码的消息以恢复基础
      哈希值，然后将其与新计算的哈希值进行比较。
      这样做的好处是需要较少的中间存储空间
      （两个哈希值，而不是两个编码后的消息），但是
      缺点是需要附加代码。

9。带附录的签名编码方法

   编码方法由在八位字节串之间映射的操作组成
   消息和八位字节编码的消息，它们被转换为
   以及方案中的整数消息代表。整数
   消息代表通过原语进行处理。这
   因此，编码方法提供了方案之间的联系，
   哪个处理消息和原语。

   出于以下目的，带有附录的签名的编码方法：
   本文档由一个编码操作和一个可选的
   验证操作。编码操作将消息M映射到
   指定长度的已编码消息EM。验证作业
   确定消息M和编码消息EM是否为
   一致，即编码后的消息EM是否为有效编码
   消息M。

   编码操作可能会引入一些随机性，因此
   对同一条消息进行编码操作的不同应用
   会产生不同的编码消息，这对
   可证明的安全性。对于这种编码方法，编码和
   除非验证者可以复制，否则需要进行验证操作
   随机性（例如，通过从签名者获得盐值）。
   对于确定性编码方法，仅编码操作为
   需要。

   带有签名的两种编码方法在附录中使用
   签名方案，并在此处指定：EMSA-PSS和
   EMSA-PKCS1-v1_5。










Moriarty等。信息性[第39页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


9.1。紧急救护系统

   通过选择哈希函数可以对这种编码方法进行参数化，
   面罩生成功能和盐长。这些选项应该是
   固定给定的RSA密钥，除了盐长度可以是
   变量（有关讨论，请参见[ JONSSON ]）。建议的哈希和掩码
   生成函数在附录B中给出。编码方法是
   基于Bellare和Rogaway的概率签名方案（PSS）
   [ RSARABIN ] [PSS]。它是随机的并具有编码操作，并且
   验证操作。

   图2说明了编码操作。

      __________________________________________________________________

                                     + ----------- +
                                     | M |
                                     + ----------- +
                                           |
                                           伏特
                                         杂凑
                                           |
                                           伏特
                             + -------- + ---------- + ---------- +
                        M'= | Padding1 | mHash | 盐|
                             + -------- + ---------- + ---------- +
                                            |
                  + -------- + ---------- + V
            DB = | Padding2 | 盐| 杂凑
                  + -------- + ---------- + |
                            | |
                            V |
                           xor <-MGF <--- |
                            | |
                            | |
                            VV
                  + ------------------- + ---------- +-+
            EM = | maskedDB | H | bc |
                  + ------------------- + ---------- +-+
      __________________________________________________________________

   图2：EMSA-PSS编码操作

   请注意，验证操作遵循相反的步骤进行恢复
   盐，然后提出重新计算和比较H的步骤。






Moriarty等。信息性[第40页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   笔记：

   1.此处定义的编码方法与Bellare中的编码方法不同
       Rogaway在三个方面向IEEE 1363a [ PSS ]提交：

       *它应用哈希函数而不是掩码生成
          消息功能。即使面膜产生
          函数基于哈希函数，似乎更自然
          直接应用哈希函数。

       *与salt值一起哈希的值是
          字符串（0x）00 00 00 00 00 00 00 00 || mHash而不是
          消息M本身。在这里，mHash是M的哈希。请注意，
          哈希函数在两个步骤中都相同。请参阅下面的注释3
          进行进一步的讨论。（此外，使用名称“盐”
          而不是“种子”，因为它更能反映出价值的
          角色。）

       * EMSA-PSS中的编码消息有9个固定位；首先
          位为0，最后八位形成“尾部字段”，
          八位位组0xbc。在原始方案中，只有第一位是
          固定的。拖车领域的基本原理是
          与整数分解签名的兼容性
          在IEEE 1363中使用Rabin-Williams（IFSP-RW）的原语
          [ IEEE1363 ]和ISO / IEC中的相应原语
          9796-2：2010 [ ISO9796 ]。

   2.假设掩码生成函数基于哈希
       函数，建议哈希函数与
       应用于消息的那个；参见8.1节的
       进一步讨论。

   3.在不损害RSASSA-PSS的安全性证明的前提下，
       执行EMSA-PSS-ENCODE和EMSA-PSS-VERIFY的第1步和第2步（
       散列函数在消息外的应用）
       计算其余签名操作的模块，以便
       将mHash而不是消息M本身输入到模块中。
       换句话说，RSASSA-PSS的安全性证明仍然有效
       即使对手可以控制mHash的值。这是
       如果模块的I / O带宽有限，例如智能
       卡片。请注意，以前版本的PSS [ RSARABIN ] [PSS]没有
       具有此属性。当然，对于其他人可能是可取的
       出于安全原因，要求模块处理完整消息。
       例如，如果
       它不信任计算哈希值的组件。






Moriarty等。信息性[页41]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   4.以八位字节为单位的典型盐长度为hLen（输出的长度
       哈希函数Hash）和0表示。在两种情况下，
       RSASSA-PSS可能与反转硬度密切相关
       RSAVP1。Bellare和Rogaway [ RSARABIN ]给出了一个较低的下限
       为了确保原始RSA-PSS方案的安全性，
       大致对应于前一种情况，而Coron [ FDH ]给出了一个
       相关的全域哈希方案的下限
       大致对应于后一种情况。在[ PSSPROOF ]中，科隆
       提供各种盐长范​​围的常规治疗
       从0到hLen; 参见[ IEEE1363A ]进行讨论。也可以看看
       [ JONSSON ]，它适应了[ RSARABIN ]中的安全性证明
       [ PSSPROOF ]解决原始图片和
       上面注释1中列出的RSA-PSS的当前版本。

   5.如IEEE 1363a [ IEEE1363A ]所述，在
       签名方案-例如EMSA-PSS中的盐值-可能会
       提供一个“隐蔽通道”来传输其他信息
       而不是正在签名的消息。有关秘密渠道的更多信息，请参见
       [ SIMMONS ]。

9.1.1。编码操作

   EMSA-PSS-ENCODE（M，emBits）

   选项：

      散列散列函数（hLen表示字节的长度，以八位字节为单位）
               哈希函数输出）
      MGF遮罩生成功能
      sLen预期的长度（以八位字节为单位）

   输入：

      要编码的M条消息，一个八位字节串
      emBits整数OS2IP（EM）的最大位长度（请参见第
               4.2节），至少8hLen + 8sLen + 9

   输出：

      EM编码的消息，长度为emLen = \ ceil的八位字节字符串
               （emBi​​ts / 8）

   错误：“编码错误”；“消息太长”








Moriarty等。信息性[页42]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   脚步：

      1.如果M的长度大于输入的限制
           哈希函数（SHA-1为2 ^ 61-1个八位位组），输出
           “消息太长”并停止。

      2.令mHash = Hash（M），长度为hLen的八位字节串。

      3.如果emLen <hLen + sLen + 2，则输出“编码错误”并停止。

      4.生成长度为sLen的随机八比特组字符串盐；如果sLen =
           0，则salt为空字符串。

      5.让

              M'=（0x）00 00 00 00 00 00 00 00 || mHash || 盐;

           M'是长度为8 + hLen + sLen的八位字节串
           初始零个八位位组。

      6.令H = Hash（M'），长度为hLen的八位字节串。

      7.生成一个由emLen-sLen-hLen组成的八位字节串PS
           -2个零八位位组。PS的长度可以为0。

      8.令DB = PS || 0x01 || 盐; DB是长度为八位字节的字符串
           emLen-hLen-1。

      9.令dbMask = MGF（H，emLen-hLen-1）。

      10.让maskedDB = DB \ xor dbMask。

      11.设置最左边的八位位组的最左边的8emLen-emBits位
           在maskedDB中为零。

      12.令EM = maskedDB || H || 0xbc。

      13.输出EM。













Moriarty等。信息性[页43]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


9.1.2。验证作业

   EMSA-PSS-VERIFY（M，EM，emBits）

   选项：

      散列散列函数（hLen表示字节的长度，以八位字节为单位）
               哈希函数输出）
      MGF遮罩生成功能
      sLen预期的长度（以八位字节为单位）

   输入：

      待验证的M消息，八位字节字符串
      EM编码的消息，长度为emLen = \ ceil的八位字节字符串
               （emBi​​ts / 8）
      emBits整数OS2IP（EM）的最大位长度（请参见第
               4.2节），至少8hLen + 8sLen + 9

   输出：“一致”或“不一致”

   脚步：

      1.如果M的长度大于输入的限制
           哈希函数（SHA-1为2 ^ 61-1个八位位组），输出
           “不一致”并停止。

      2.令mHash = Hash（M），长度为hLen的八位字节串。

      3.如果emLen <hLen + sLen + 2，则输出“不一致”并停止。

      4.如果EM最右边的八位组没有十六进制值
           0xbc，输出“不一致”并停止。

      5.让maskedDB为EM的最左边的emLen-hLen-1个八位位组，
           并让H为下一个hLen八位位组。

      6.如果最左边的8emLen-最左边八位位组的emBits位
           maskedDB并不都等于零，输出“不一致”并且
           停止。

      7.令dbMask = MGF（H，emLen-hLen-1）。

      8.让DB = maskedDB \ xor dbMask。

      9.设置最左边的八位位组的最左边的8emLen-emBits位
           在数据库中为零。




Moriarty等。信息性[页44]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


      10.如果emLen-hLen-sLen-DB的最左边的两个八位位组不是
           零或八位位组在emLen-hLen-sLen-1（
           最左边的位置是“位置1”）没有十六进制
           值0x01，输出“不一致”并停止。

      11.令salt为DB的最后一个sLen八位位组。

      12.让

              M'=（0x）00 00 00 00 00 00 00 00 || mHash || 盐 ;

           M'是长度为8 + hLen + sLen的八位字节串
           初始零个八位位组。

      13.令H'= Hash（M'），长度为hLen的八位字节串。

      14.如果H = H'，则输出“一致”。否则，输出
           “不一致”。

9.2。EMSA-PKCS1-v1_5

   此编码方法是确定性的，仅具有编码
   手术。

   EMSA-PKCS1-v1_5-ENCODE（M，emLen）

   选项：

      散列散列函数（hLen表示字节的长度，以八位字节为单位）
               哈希函数输出）

   输入：

      M消息要编码
      emLen编码消息的八位字节的预期长度，在
               至少tLen + 11，其中tLen是
               对T的T进行编码的可分辨编码规则（DER）
               在编码操作中计算出的某个值

   输出：

      EM编码的消息，长度为emLen的八位字节字符串

   错误：“消息太长”；“预期的编码消息长度也
      短的”






Moriarty等。信息性[第45页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   脚步：

      1.将哈希函数应用于消息M以产生哈希
          值H：

             H =哈希（M）。

          如果哈希函数输出“消息太长”，则输出
          “消息太长”并停止。

      2.编码哈希函数和哈希的算法ID
          值转换为DigestInfo类型的ASN.1值（请参阅
          带有DER的附录A.2.4），其中DigestInfo类型具有
          语法

               DigestInfo :: = SEQUENCE {
                   摘要算法算法标识符，
                   摘要OCTET STRING
               }

          第一个字段标识哈希函数，第二个字段标识
          包含哈希值。令T为的DER编码
          DigestInfo值（请参见下面的注释），并让tLen为
          T的八位字节长度。

      3.如果emLen <tLen + 11，则输出“预期的编码消息长度”
          太短”并停止。

      4.生成一个由emLen-tLen-3组成的八位字节串PS
          十六进制值为0xff的八位字节。PS的长度将是
          至少8个八位位组。

      5.连接PS，编码T的DER和其他填充以形成
          编码的消息EM为

             EM = 0x00 || 0x01 || PS || 0x00 || T.

      6.输出EM。













Moriarty等。信息性[页46]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   笔记：

   1.对于附录B.1中提到的九种哈希函数，DER
       DigestInfo值的编码T等于以下值：

         MD2：（0x）30 20 30 0c 06 08 2a 86 48 86 f7 0d 02 02 05 00 04
                      10 || H。
         MD5：（0x）30 20 30 0c 06 08 2a 86 48 86 f7 0d 02 05 05 00 04
                      10 || H。
         SHA-1：（0x）30 21 30 09 06 05 2b 0e 03 02 1a 05 00 04 14 || H。
         SHA-224：（0x）30 2d 30 0d 06 09 60 86 48 01 65 03 04 02 04
                      05 00 04 1c || H。
         SHA-256：（0x）30 31 30 0d 06 09 60 86 48 01 65 03 04 02 01 05 00
                      04 20 || H。
         SHA-384：（0x）30 41 30 0d 06 09 60 86 48 01 65 03 04 02 02 05 00
                      04 30 || H。
         SHA-512：（0x）30 51 30 0d 06 09 60 86 48 01 65 03 04 02 03 05 00
                      04 40 || H。
         SHA-512 / 224：（0x）30 2d 30 0d 06 09 60 86 48 01 65 03 04 02 05
                           05 00 04 1c || H。
         SHA-512 / 256：（0x）30 31 30 0d 06 09 60 86 48 01 65 03 04 02 06
                           05 00 04 20 || H。

   2.在本文档的版本1.5中，T被定义为BER。
       编码，而不是DER编码。
       特别是，至少在理论上，
       本文档（以及本文档中定义的验证操作）
       2.0版）拒绝对以下内容有效的签名
       PKCS＃1 v1.5中给出的规范。如果其他
       比DER规则更适用于DigestInfo（例如，不确定的
       基础SEQUENCE类型的长度编码）。虽然这是
       不太可能在实践中引起关注，谨慎的实现者可能
       选择采用基于BER解码的验证操作
       PKCS＃1 v1.5中指定的操作。以这种方式，
       与任何基于PKCS＃1 v1.5的有效实现兼容
       获得。此类验证操作应表明
       基础BER编码是否为DER编码，因此
       签名相对于规范是否有效
       在本文档中给出。

10。安全注意事项

   整个备忘录中都讨论了安全注意事项。








Moriarty等。信息性[页47]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


11。参考

11.1。规范性引用

   [ GARNER ] Garner，H.，“残数系统”，IRE交易
              在电子计算机上，第EC-8卷，第2期，页。
              140-147，DOI 10.1109 / TEC.1959.5219515，1959年6月。

   [ RFC2119 ] Bradner，S.，“在RFC中用于指示的关键字
              需求级别”，BCP 14，RFC 2119，
              DOI 10.17487 / RFC2119，1997年3月，
              < http://www.rfc-editor.org/info/rfc2119 >。

   [ RSA ] Rivest，R.，Shamir，A.和L. Adleman，“一种方法
              获取数字签名和公钥
              密码系统”，ACM通信，第21卷，
              第2期，第120-126页，DOI 10.1145 / 359340.359342，2月
              1978年。

11.2。信息参考

   [ ANSIX944 ] ANSI，“使用整数分解的密钥建立
              密码术”，ANSI X9.44-2007，2007年8月。

   [ BKS ] Bleichenbacher，D.，Kaliski，B.和J. Staddon，“最近
              PKCS＃1上的结果：“ RSA加密标准”，RSA
              实验室，1998年6月第7号公告。

   [ BLEICHENBACHER ]
              Bleichenbacher，D.，“针对的选择的密文攻击
              基于RSA加密标准PKCS＃1“的协议，
              《计算机科学讲义》，第1462卷，第1-12页，
              1998年。

   [选择] Desmedt，Y.和A. Odlyzko，“对文本的选择文本攻击
              RSA密码系统和一些离散对数方案”，
              《计算机科学讲义》，第218卷，页。
              516-522，1985年。

   [ COCHRAN ] M. Cochran，“关于Wang等人的注释2 ^ 63 SHA-1
              差异路径”，密码学ePrint存档：报告
              2007 / 474，2008年8月，< http://eprint.iacr.org/2007/474 >。

   [ FASTDEC ] Quisquater，J.和C. Couvreur，“快速解密
              RSA公钥密码系统的算法”，电子
              来信，第18卷，第21期，第905-907页，
              DOI 10.1049 / el：19820617，1982年10月。




Moriarty等。信息性[页48]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   [ FDH ] Coron，J.，“关于完整域哈希的确切安全性”，
              《计算机科学讲义》，第1880卷，第pp。
              229-235，2000。

   [ FOPS ]藤崎（E.），冈本（T.），冈比亚（T.Pointcheval）和J.斯特恩（J. Stern），
              演讲中的“ RSA假设下的RSA-OAEP是安全的”
              Notes in Computer Science，第2139卷，第260-274页，
              2001年8月。

   [伪造]铜史密斯（D.），哈勒维（S. Halevi）和S.尤拉（C. Jutla），“ ISO 9796-1和
              新的伪造策略”，Crypto的下届会议，8月
              1999年。

   [ HAASTAD ] Haastad，J.，“求解
              低学位”，SIAM计算杂志，第17卷
              1988年4月，DOI 10.1137 / 0217019，第2期，336-341页。

   [手册] Menezes，A.，van Oorschot，P.和S. Vanstone，“手册
              “应用密码学”，CRC出版社，ISBN：0849385237，
              1996年。

   [ HASHID ] B. Kaliski，“关于签名中的哈希函数防火墙
              方案”，《计算机科学讲义》，第2271卷，
              1-16页，DOI 10.1007 / 3-540-45760-7_1，2002年2月。

   [ IEEE1363 ] IEEE，“公钥标准规范
              密码术”，IEEE Std 1363-2000，
              DOI 10.1109 / IEEESTD.2000.92292，2000年8月，
              < http://ieeexplore.ieee.org/document/891000/ >。

   [ IEEE1363A ]
              IEEE，“公钥密码术的标准规范”
              -修正案1：其他技术“，IEEE Std 1363a-
              2004年，DOI 10.1109 / IEEESTD.2004.94612，2004年9月，
              < http://ieeexplore.ieee.org/document/1335427/ >。

   [ ISO18033 ]国际标准化组织，
              “信息技术-安全技术-
              加密算法-第2部分：非对称密码”，ISO /
              IEC 18033-2：2006，2006年5月。

   [ ISO9594 ]国际标准化组织，
              “信息技术-开放系统互连-
              目录：公钥和属性证书
              框架”，ISO / IEC 9594-8：2008，2008年12月。






Moriarty等。信息性[第49页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   [ ISO9796 ]国际标准化组织，
              “信息技术-安全技术-数字
              提供消息恢复的签名方案-第2部分：
              基于整数分解的机制”，
              ISO / IEC 9796-2：2010，2010年12月。

   [ JONSSON ] Jonsson，J。，“ RSA-PSS签名的安全证明
              方案及其变体”，密码学ePrint
              档案：2002/053号报告，2002年3月，
              < http://eprint.iacr.org/2001/053 >。

   [ LOWEXP ]铜史密斯D.，富兰克林M.，帕塔林J.和M. Reiter，
              “带有相关消息的低指数RSA”，第3部分中的讲义
              《计算机科学》，第1070卷，第1-9页，1996年。

   [ MANGER ] J. Manger，“对RSA最优选择的密文攻击
              不对称加密填充（OAEP）在
              PKCS＃1 v2.0”，计算机科学讲义，第1卷
              2139，第230-238页，DOI 10.1007 / 3-540-44647-8_14，2001年。

   [ MD4 ] Dobbertin，H。，“ MD4的密码分析”，
              计算机科学，第1039卷，第53-69页，
              DOI 10.1007 / 3-540-60865-6_43，1996年。

   [ MD4FIRST ] Dobbertin，H。，“ MD4的前两轮不是一个-
              方式”，《计算机科学讲义》，第1372卷，第11页。
              284-292，DOI 10.1007 / 3-540-69710-1_19，1998年3月。

   [ MD4LAST ] den Boer，B。和A. Bosselaers，“对最后两个国家的攻击
              回合的MD4”，计算机科学讲义，第1卷
              576，第194-203页，DOI 10.1007 / 3-540-46766-1_14，1992。

   [ NEWATTACK ]
              Coron，J.，Joye，M.，Naccache，D.和P. Paillier，“新
              攻击PKCS＃1 v1.5加密”，
              计算机科学，第1807卷，第369-381页，
              DOI 10.1007 / 3-540-45539-6_25，2000年5月。

   [ OAEP ] Bellare，M.和P. Rogaway，“最佳非对称加密
              -如何使用RSA加密”，计算机讲义
              1995年11月，《科学》，第950卷，第92-111页。

   [ PA98 ] Bellare，M.，Desai，A.，Pointcheval，D.和P. Rogaway，
              “公钥安全性概念之间的关系
              加密方案”，计算机讲义
              科学，第1462卷，第26-45页，DOI 10.1007 / BFb0055718，
              1998年。




Moriarty等。信息性[第50页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   [填充] Coron，J.，Naccache，D.和J. Stern，“关于安全性
              RSA Padding”，计算机科学讲义，第1卷
              1666年，第1-18页，DOI 10.1007 / 3-540-48405-1_1，12月
              1999年。

   [ PKCS1_22 ] RSA实验室，“ PKCS＃1：RSA密码学标准
              2.2版，2012年10月。

   [ PREFIX ] Stevens，M.，Lenstra，A.和B. de Weger，“选择前缀
              MD5和应用程序的冲突”，国际
              应用密码学杂志，第2卷，第4期，第pp。
              322-359，2012年7月。

   [ PSS ] Bellare，M.和P. Rogaway，“ PSS：证明是安全的编码
              数字签名方法”，提交给IEEE P1363a，
              1998年8月，< http://grouper.ieee.org/groups/1363/ 
              P1363a / contributions / pss-submission.pdf >。

   [ PSSPROOF ] Coron，J.，“用于PSS和其他产品的最佳安全性证明
              签名方案”，计算机讲义
              科学，第2332卷，第272-287页，
              DOI 10.1007 / 3-540-46035-7_18，2002年。

   [ RFC1319 ] B. Kaliski，“ MD2消息摘要算法”，RFC 1319，
              DOI 10.17487 / RFC1319，1992年4月，
              < http://www.rfc-editor.org/info/rfc1319 >。

   [ RFC1321 ] Rivest，R。，“ MD5消息摘要算法”，RFC 1321，
              DOI 10.17487 / RFC1321，1992年4月，
              < http://www.rfc-editor.org/info/rfc1321 >。

   [ RFC2313 ] B. Kaliski，“ PKCS＃1：RSA加密版本1.5”，
               RFC 2313，DOI 10.17487 / RFC2313，1998年3月，
              < http://www.rfc-editor.org/info/rfc2313 >。

   [ RFC2315 ] B. Kaliski，“ PKCS＃7：加密消息语法
              1.5版”，RFC 2315，DOI 10.17487 / RFC2315，1998年3月，
              < http://www.rfc-editor.org/info/rfc2315 >。

   [ RFC2437 ] Kaliski，B.和J. Staddon，“ PKCS＃1：RSA密码术
              规格版本2.0“，RFC 2437，
              DOI 10.17487 / RFC2437，1998年10月，
              < http://www.rfc-editor.org/info/rfc2437 >。

   [ RFC3447 ] Jonsson，J。和B. Kaliski，“公共密钥密码术
              标准（PKCS）＃1：RSA密码规范
              2.1版”，RFC 3447，DOI 10.17487 / RFC3447，2月
              2003，< http://www.rfc-editor.org/info/rfc3447 >。



Moriarty等。信息性[Page 51]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   [ RFC5246 ] Dierks，T.和E. Rescorla，“传输层安全性
              （TLS）协议版本1.2”，RFC 5246，
              DOI 10.17487 / RFC5246，2008年8月，
              < http://www.rfc-editor.org/info/rfc5246 >。

   [ RFC5652 ] Housley，R.，“加密消息语法（CMS）”，STD 70，
               RFC 5652，DOI 10.17487 / RFC5652，2009年9月，
              < http://www.rfc-editor.org/info/rfc5652 >。

   [ RFC5958 ] Turner，S.，“非对称密钥包”，RFC 5958，
              DOI 10.17487 / RFC5958，2010年8月，
              < http://www.rfc-editor.org/info/rfc5958 >。

   [ RFC6149 ] Turner，S.和L. Chen，“ MD2的历史地位”，
               RFC 6149，DOI 10.17487 / RFC6149，2011年3月，
              < http://www.rfc-editor.org/info/rfc6149 >。

   [ RFC7292 ] Moriarty，K.，Ed。，Nystrom，M.，Parkinson，S.，Rusch，A.，
              和M. Scott，“ PKCS＃12：个人信息交换
              语法v1.1”，RFC 7292，DOI 10.17487 / RFC7292，2014年7月，
              < http://www.rfc-editor.org/info/rfc7292 >。

   [ RSARABIN ] Bellare，M.和P. Rogaway，“数字的精确安全性
              签名-如何使用RSA和Rabin签名”，演讲
              Notes in Computer Science，第1070卷，第399-416页，
              DOI 10.1007 / 3-540-68339-9_34，1996年。

   [ RSATLS ] Jonsson，J。和B. Kaliski，“关于RSA的安全性
              TLS中的加密”，计算机讲义
              科学，第2442卷，第127-142页，
              DOI 10.1007 / 3-540-45708-9_9，2002。

   [ SHA1CRYPT ]
              Wang X，Yao，A.和F. Yao，“ SHA-1的密码分析”，
              《计算机科学讲义》，第2442卷，页。
              2005年2月12日至12日，
              < http://csrc.nist.gov/groups/ST/hash/documents/ 
              Wang_SHA1-New-Result.pdf >。

   [ SHOUP ] Shoup，V.，“重新考虑OAEP（扩展摘要）”，
              《计算机科学讲义》，第2139卷，页。
              239-259，DOI 10.1007 / 3-540-44647-8_15，2001年。

   [ SHS ]国家标准技术研究院，“安全
              哈希标准（SHS）”，FIPS PUB 180-4，2015年8月，
              < http://dx.doi.org/10.6028/NIST.FIPS.180-4 >。





Moriarty等。信息性[页52]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   [银人]
              Silverman，R.，“基于成本的安全性分析
              对称和非对称密钥长度”，RSA
              实验室，2000年第13号公告。

   [ SIMMONS ] G. Simmons，“使用
              DSA”，计算机科学讲义，第765卷，第pp。
              218-232，DOI 10.1007 / 3-540-48285-7_18，1994。











































Moriarty等。信息性[页53]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


附录A。ASN.1语法

A.1。RSA密钥表示

   本部分定义了RSA public和RSA的ASN.1对象标识符。
   私钥，并定义类型RSAPublicKey和RSAPrivateKey。
   这些定义的预期应用包括X.509
   证书，PKCS＃8 [ RFC5958 ]和PKCS＃12 [ RFC7292 ]。

   对象标识符rsaEncryption标识RSA公共和私有
   附录A.1.1和A.1.2中定义的键。参数字段
   在类型为AlgorithmIdentifier的值中与此OID相关联
   应具有NULL类型的值。

      rsaEncryption对象标识符:: = {pkcs-1 1}

   本节中的定义已扩展为支持多
   主要RSA，但它们与以前的版本向后兼容。

A.1.1。RSA公钥语法

   RSA公钥应使用ASN.1类型表示
   RSAPublicKey：

         RSAPublicKey :: = SEQUENCE {
             模数INTEGER，-n
             publicExponent整数-e
         }

   RSAPublicKey类型的字段具有以下含义：

   o模数是RSA模数n。

   o publicExponent是RSA公共指数e。

















Moriarty等。信息性[Page 54]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


A.1.2。RSA私钥语法

   RSA私钥应使用ASN.1类型表示
   RSAPrivateKey：

         RSAPrivateKey :: = SEQUENCE {
             版本Version，
             模数INTEGER，-n
             publicExponent整数--e
             privateExponent整数--d
             prime1 INTEGER，-p
             prime2 INTEGER，-q
             指数1整数--d mod（p-1）
             exponent2整数，-d mod（q-1）
             系数INTEGER，-（q的倒数）mod p
             otherPrimeInfos OtherPrimeInfos可选
         }

   RSAPrivateKey类型的字段具有以下含义：

   o version是版本号，以与将来兼容
      本文档的修订版。对于此版本的，它应为0
      文档，除非使用多重质数；在这种情况下，应该是
      1。

            版本:: = INTEGER {二素（0），multi（1）}
               （受约束
               {-如果存在其他PrimeInfos，则版本必须为多-}）

   o模数是RSA模数n。

   o publicExponent是RSA公共指数e。

   o privateExponent是RSA私有指数d。

   o prime1是n的素数因子p。

   o prime2是n的质因子q。

   o指数1是d mod（p-1）。

   o exponent2是d mod（q-1）。

   o系数是CRT系数q ^（-1）mod p。







Moriarty等。信息性[Page 55]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   o otherPrimeInfos包含其他素数的信息
      r_3，...，r_u，按顺序。如果version为0且应将其省略
      如果版本，则应至少包含OtherPrimeInfo的一个实例
      是1。

            OtherPrimeInfos :: = OtherPrimeInfo的SEQUENCE SIZE（1..MAX）

            OtherPrimeInfo :: = SEQUENCE {
                原始整数--ri
                指数INTEGER，-di
                系数INTEGER-ti
            }

   类型OtherPrimeInfo的字段具有以下含义：

   o素数是n的素数因子r_i，其中i> = 3。

   o指数为d_i = d mod（r_i-1）。

   o系数是CRT系数t_i =（r_1 * r_2 * ... *
      r_（i-1））^（-1）mod r_i。

   注意：保护RSA私钥不受两者的侵害很重要
   披露和修改。这种保护的技术是
   超出本文档的范围。存储和存储方法
   描述了分配私钥和其他密码数据
   在PKCS＃12和＃15中。
























Moriarty等。信息性[Page 56]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


A.2。方案识别

   本节定义用于加密和加密的对象标识符。
   签名方案。与PKCS＃1 v1.5兼容的方案具有
   与PKCS＃1 v1.5中的定义相同。的预期应用
   这些定义包括X.509证书和PKCS＃7。

   以下是PKCS＃1 OID的类型标识符定义：

   PKCS1算法算法标识符:: = {
       {OID rsaEncryption参数为空} |
       {OID md2WithRSAEncryption参数为空} |
       {OID md5WithRSAEncryption参数为空} |
       {OID sha1WithRSAEncryption参数NULL} |
       {OID sha224WithRSAEncryption参数为空} |
       {OID sha256WithRSAEncryption参数NULL} |
       {OID sha384WithRSAEncryption参数为空} |
       {OID sha512WithRSAEncryption参数NULL} |
       {OID sha512-224WithRSAEncryption参数为空} |
       {OID sha512-256WithRSAEncryption参数NULL} |
       {OID id-RSAES-OAEP参数RSAES-OAEP参数} |
       PKCS1PSourceAlgorithms |
       {OID id-RSASSA-PSS参数RSASSA-PSS参数}，
       ...-允许将来扩展-
   }

A.2.1。RSAES-OAEP

   对象标识符id-RSAES-OAEP标识RSAES-OAEP
   加密方案。

       id-RSAES-OAEP对象标识符:: = {pkcs-1 7}

   与此OID关联的parameter字段，类型为value
   AlgorithmIdentifier应具有RSAES-OAEP-params类型的值：

   RSAES-OAEP-params :: = SEQUENCE {
       hashAlgorithm [0] HashAlgorithm默认值sha1，
       maskGenAlgorithm [1] MaskGenAlgorithm DEFAULT mgf1SHA1，
       pSourceAlgorithm [2] PSourceAlgorithm缺省pSpecifiedEmpty
   }

   RSAES-OAEP-params类型的字段具有以下含义：

   hashAlgorithm标识哈希函数。它应该是
      OAEP-PSSDigestAlgorithms集中具有OID的算法ID。为了
      有关受支持的哈希函数的讨论，请参见附录B.1。




Moriarty等。信息性[Page 57]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


       HashAlgorithm :: = AlgorithmIdentifier {
          {OAEP-PSSDigestAlgorithms}
       }

       OAEP-PSSDigestAlgorithms算法标识符:: = {
           {OID id-sha1参数为空} |
           {OID id-sha224参数NULL} |
           {OID id-sha256参数NULL} |
           {OID id-sha384参数NULL} |
           {OID id-sha512参数NULL} |
           {OID id-sha512-224参数NULL} |
           {OID id-sha512-256参数NULL}，
           ...-允许将来扩展-
       }

   默认的哈希函数是SHA-1：

       sha1 HashAlgorithm :: = {
           算法id-sha1，
           参数SHA1Parameters：NULL
       }

       SHA1Parameters :: =空

   o maskGenAlgorithm标识掩码生成函数。它
      应当是集合中带有OID的算法ID
      PKCS1MGF算法，对于此版本，应包括
      id-mgf1，标识MGF1掩码生成功能（请参阅
      附录B.2.1）。与id-mgf1关联的参数字段
      应当是集合中带有OID的算法ID
      OAEP-PSSDigestAlgorithms，标识要在其上使用的哈希函数
      以MGF1为基础。

       MaskGenAlgorithm :: = AlgorithmIdentifier {{PKCS1MGFAlgorithms}}

       PKCS1MGF算法算法标识符:: = {
           {OID id-mgf1参数HashAlgorithm}，
           ...-允许将来扩展-
       }

   o默认的掩码生成功能是带有SHA-1的MGF1：

       mgf1SHA1 MaskGenAlgorithm :: = {
           算法id-mgf1，
           参数HashAlgorithm：sha1
       }





Moriarty等。信息性[页58]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   pSourceAlgorithm标识源（可能还有值）
      标签L。它应该是一个算法ID，其中的OID位于集合中
      PKCS1PSourceAlgorithms，对于此版本，应包括
      id-pSpecified，指示标签是明确指定的。
      与id-pSpecified关联的参数字段应具有一个
      OCTET STRING类型的值，包含标签。在上一个
      在本规范的版本中，术语“编码参数”为
      使用而不是“标签”，因此是以下类型的名称。

       PSourceAlgorithm :: = AlgorithmIdentifier {
          {PKCS1PSourceAlgorithms}
       }

       PKCS1PSourceAlgorithms算法IDENTIFIER :: = {
           {OID id-pSpecified PARAMETERS EncodingParameters}，
           ...-允许将来扩展-
       }

       id-p指定的对象标识符:: = {pkcs-1 9}

       EncodingParameters :: = OCTET STRING（SIZE（0..MAX））

   o默认标签是一个空字符串（因此lHash将包含
      空字符串的哈希值）：

       pSpecifiedEmpty PSourceAlgorithm :: = {
           算法id-pSpecified，
           参数EncodingParameters：emptyString
       }

       emptyString EncodingParameters :: =''H

   如果RSAES-OAEP-params中字段的所有默认值均为
   使用，则算法标识符将具有以下值：

       rSAES-OAEP-默认标识符RSAES-AlgorithmIdentifier :: = {
           算法ID-RSAES-OAEP，
           参数RSAES-OAEP-params：{
               hashAlgorithm sha1，
               maskGenAlgorithm mgf1SHA1，
               pSourceAlgorithm pSpecifiedEmpty
           }
       }

       RSAES-AlgorithmIdentifier :: = AlgorithmIdentifier {
           {PKCS1Algorithms}
       }




Moriarty等。信息性[Page 59]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


A.2.2。RSAES-PKCS-v1_5

   对象标识符rsaEncryption（请参阅附录A.1）标识了
   RSAES-PKCS1-v1_5加密方案。与参数字​​段关联
   该OID的值类型为AlgorithmIdentifier时，应具有
   NULL类型的值。这与PKCS＃1 v1.5中的相同。

       rsaEncryption对象标识符:: = {pkcs-1 1}

A.2.3。RSASSA-PSS

   对象标识符id-RSASSA-PSS标识RSASSA-PSS
   加密方案。

       id-RSASSA-PSS对象标识符:: = {pkcs-1 10}

   与此OID关联的parameter字段，类型为value
   AlgorithmIdentifier应具有RSASSA-PSS-params类型的值：

   RSASSA-PSS-params :: = SEQUENCE {
       hashAlgorithm [0] HashAlgorithm默认值sha1，
       maskGenAlgorithm [1] MaskGenAlgorithm DEFAULT mgf1SHA1，
       saltLength [2]整数默认值20，
       trailerField [3] TrailerField默认值trailerFieldBC
   }

   RSASSA-PSS-params类型的字段具有以下含义：

   hashAlgorithm标识哈希函数。它应该是
      OAEP-PSSDigestAlgorithms集中具有OID的算法ID（请参阅
      附录A.2.1）。默认的哈希函数是SHA-1。

   o maskGenAlgorithm标识掩码生成函数。它
      应当是一组PKCS1MGFAlgorithms中具有OID的算法ID
      （请参阅附录A.2.1）。默认的遮罩生成功能为
      具有SHA-1的MGF1。对于MGF1（更一般而言，对于其他面罩
      基于哈希函数的生成函数），建议
      基础哈希函数与一个相同
      由hashAlgorithm标识；见注2在第9.1节作进一步
      注释。

   o saltLength是盐的八位位组长度。它应该是
      整数。对于给定的hashAlgorithm，默认值为
      saltLength是哈希值的八位字节长度。不像
      RSASSA-PSS-params类型的其他字段，saltLength不需要
      固定给定的RSA密钥对。





Moriarty等。信息性[第60页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   o trailerField是预告片字段编号，用于与
      IEEE 1363a [ IEEE1363A ]。这个版本的
      文档，以十六进制表示预告片字段
      值0xbc。其他拖车场（包括拖车场）
      HashID || 本文档不支持IEEE 1363a中的0xcc）。

       TrailerField :: =整数{trailerFieldBC（1）}

   如果hashAlgorithm，maskGenAlgorithm和
   使用RSASSA-PSS-params的trailerField字段，然后使用算法
   标识符将具有以下值：

       rSASSA-PSS-默认标识符RSASSA-AlgorithmIdentifier :: = {
           算法ID-RSASSA-PSS，
           参数RSASSA-PSS-params：{
               hashAlgorithm sha1，
               maskGenAlgorithm mgf1SHA1，
               saltLength 20，
               trailerField trailerFieldBC
           }
       }

       RSASSA-AlgorithmIdentifier :: = AlgorithmIdentifier {
           {PKCS1Algorithms}
       }

   注意：在某些应用程序中，签名基础的哈希函数
   方案与以下中的其他操作分开标识
   签名方案。例如，在PKCS＃7 [ RFC2315 ]中，哈希
   功能标识符放在消息之前，“摘要
   加密”算法标识符（表示其余
   作业）随签名一起携带。为了使PKCS＃7
   支持RSASSA-PSS签名方案，则对象标识符将
   哈希后需要为RSASSA-PSS中的操作定义
   函数（类似于RSAEncryption OID的
   RSASSA-PKCS1-v1_5方案）。S / MIME加密消息语法（CMS）
   [ RFC5652 ]采用了不同的方法。虽然是散列函数
   标识符放置在消息之前，算法标识符用于
   完整的签名方案可以与CMS签名一起携带（此
   完成DSA签名）。按照这个惯例，
   id-RSASSA-PSS OID可用于识别以下内容中的RSASSA-PSS签名
   CMS。由于CMS被认为是PKCS＃7和新版本的继任者
   诸如增加对RSASSA-PSS的支持等发展
   相对于CMS而不是PKCS＃7（“其余”的OID
   在此版本的PKCS＃1中未定义“ RSASSA-PSS”。






Moriarty等。信息性[Page 61]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


A.2.4。RSASSA-PKCS-v1_5

   RSASSA-PKCS1-v1_5的对象标识符应为以下内容之一：
   下列的。OID的选择取决于哈希的选择
   算法：MD2，MD5，SHA-1，SHA-224，SHA-256，SHA-384，SHA-512，
   SHA-512 / 224或SHA-512 / 256。请注意，如果使用MD2或MD5，
   那么OID就像PKCS＃1 v1.5中的一样。对于每个OID，
   与此OID关联的parameter字段，类型为value
   AlgorithmIdentifier应具有NULL类型的值。OID应该
   根据下表选择：

         哈希算法OID
         -------------------------------------------------- ----------
         MD2 md2WithRSAEncryption :: = {pkcs-1 2}
         MD5 md5WithRSAEncryption :: = {pkcs-1 4}
         SHA-1 sha1WithRSAEncryption :: = {pkcs-1 5}
         SHA-256 sha224WithRSAEncryption :: = {pkcs-1 14}
         SHA-256 sha256WithRSAEncryption :: = {pkcs-1 11}
         SHA-384 sha384WithRSAEncryption :: = {pkcs-1 12}
         SHA-512 sha512WithRSAEncryption :: = {pkcs-1 13}
         SHA-512 / 224 sha512-224WithRSAEncryption :: = {pkcs-1 15}
         SHA-512 / 256 sha512-256WithRSAEncryption :: = {pkcs-1 16}

   EMSA-PKCS1-v1_5编码方法包括类型为ASN.1的值
   DigestInfo，其中DigestInfo类型具有语法

       DigestInfo :: = SEQUENCE {
           摘要算法DigestAlgorithm，
           摘要OCTET STRING
       }

   摘要算法标识哈希函数，并且应为
   在PKCS1-v1-5DigestAlgorithms集中具有OID的算法ID。为了
   有关受支持的哈希函数的讨论，请参见附录B.1。

















Moriarty等。信息性[Page 62]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


       DigestAlgorithm ::: AlgorithmIdentifier {
          {PKCS1-v1-5DigestAlgorithms}
       }

       PKCS1-v1-5DigestAlgorithms算法标识符:: = {
           {OID id-md2参数为空} |
           {OID id-md5参数为空} |
           {OID id-sha1参数为空} |
           {OID id-sha224参数NULL} |
           {OID id-sha256参数NULL} |
           {OID id-sha384参数NULL} |
           {OID id-sha512参数NULL} |
           {OID id-sha512-224参数NULL} |
           {OID id-sha512-256参数NULL}
       }

附录B。配套技术

   本节提供了一些基础功能的示例
   支持第7节中的加密方案和编码第9节中的
   方法。这里给出了一系列技术，以允许
   与现有应用程序的兼容性以及向新应用程序的迁移
   技术。这些支持技术适用于
   要实施的应用程序，都不需要
   实施的。预计PKCS＃1 v2.2的配置文件将是
   开发了特定的支持技术。

   本节还提供了支持的对象标识符
   技术。

B.1。散列函数

   散列函数用于第7节和第7节中包含的操作
   9.哈希函数是确定性的，这意味着输出为
   完全由输入决定。哈希函数以八位字节为单位
   可变长度的字符串，并生成固定长度的八位位组字符串。
   第7节和第7节中包含的操作中使用的哈希函数
   9通常应防碰撞。这意味着它是
   无法为哈希函数找到两个不同的输入
   产生相同的输出。防碰撞哈希函数也
   具有单向性的理想特性；这意味着给定一个
   输出，无法找到其哈希值已指定的输入
   输出。除了要求之外，哈希函数还应该
   产生具有伪随机的掩码生成函数（附录B.2）
   输出。






Moriarty等。信息性[Page 63]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   给出了九个哈希函数作为示例中的编码方法
   本文档：MD2 [ RFC1319 ]（已由[ RFC6149 ]淘汰），MD5
   [ RFC1321 ]，SHA-1，SHA-224，SHA-256，SHA-384，SHA-512，SHA-512 / 224，
   和SHA-512 / 256 [ SHS ]。对于RSAES-OAEP加密方案和
   EMSA-PSS编码方法，仅SHA-1，SHA-224，SHA-256，SHA-384，SHA-
   推荐使用512，SHA-512 / 224和SHA-512 / 256。对于EMSA-
   PKCS1-v1_5编码方法，SHA-224，SHA-256，SHA-384，SHA-512，SHA-
   建议在新应用中使用512/224和SHA-512 / 256。MD2，
   仅建议MD5和SHA-1与现有设备兼容
   基于PKCS＃1 v1.5的应用程序。

   对象标识符id-md2，id-md5，id-sha1，id-sha224，id-sha256，
   id-sha384，id-sha512，id-sha512 / 224和id-sha512 / 256标识
   各自的哈希函数：

       id-md2对象标识符:: = {
           iso（1）成员-主体（2）我们（840）rsadsi（113549）
           摘要算法（2）2
       }

       id-md5对象标识符:: = {
           iso（1）成员-主体（2）我们（840）rsadsi（113549）
           摘要算法（2）5
       }

       id-sha1对象标识符:: = {
           iso（1）确定的组织（3）oiw（14）secsig（3）
            算法（2）26
       }

       id-sha224对象标识符:: = {
           iso-itu-itu-t（2）国家（16）美国（840）组织（1）
           gov（101）csor（3）nistalgorithm（4）hashalgs（2）4
       }

       id-sha256对象标识符:: = {
           iso-itu-itu-t（2）国家（16）美国（840）组织（1）
           gov（101）csor（3）nistalgorithm（4）hashalgs（2）1
       }

       id-sha384对象标识符:: = {
           iso-itu-itu-t（2）国家（16）美国（840）组织（1）
           gov（101）csor（3）nistalgorithm（4）hashalgs（2）2
       }







Moriarty等。信息性[Page 64]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


       id-sha512对象标识符:: = {
           iso-itu-itu-t（2）国家（16）美国（840）组织（1）
           gov（101）csor（3）nistalgorithm（4）hashalgs（2）3
       }

       id-sha512-224对象标识符:: = {
           iso-itu-itu-t（2）国家（16）美国（840）组织（1）
           gov（101）csor（3）nistalgorithm（4）hashalgs（2）5
       }

       id-sha512-256对象标识符:: = {
           iso-itu-itu-t（2）国家（16）美国（840）组织（1）
           gov（101）csor（3）nistalgorithm（4）hashalgs（2）6
       }

   与这些OID关联的parameter字段，类型为value
   AlgorithmIdentifier应具有NULL类型的值。

   与id-md2和id-md5关联的参数字段，其值为
   AlgorithmIdentifier类型的值应为NULL。

   与id-sha1，id-sha224，id-sha256，
   id-sha384，id-sha512，id-sha512 / 224和id-sha512 / 256
   通常省略，但如果存在，则其值应为type
   空值。

   这符合NIST最初发布的定义。
   对于SHA算法，实现必须接受
   无参数且带NULL的AlgorithmIdentifier值
   参数。

   例外：在EMSA-PKCS1-v1_5中格式化DigestInfoValue时
   （请参阅第9.2节），与id-sha1关联的参数字段，
   id-sha224，id-sha256，id-sha384，id-sha512，id-sha512 / 224和
   id-sha512 / 256应具有NULL类型的值。这是为了维持
   与现有实现和数字的兼容性
   已为EMSA-PKCS1-v1_5发布的信息值是
   也反映在IEEE 1363a [ IEEE1363A ]中。

   注意：PKCS＃1的1.5版还允许在以下版本中使用MD4：
   签名方案。MD4的密码分析已进行
   在随后的几年中非常重要。例如Dobbertin [ MD4 ]
   演示了如何找到MD4的碰撞以及前两个
   轮次MD4不是单向[ MD4FIRST ]。由于这些结果
   和其他（例如[ MD4LAST ]），则不建议使用MD4。

   MD2和MD5的密码分析已经取得了进一步的进展，
   特别是在史蒂文斯（Stevens）等人的发现之后。[ PREFIX ]在选定的位置上-



Moriarty等。信息性[Page 65]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   MD5上的前缀冲突。应该考虑MD2和MD5
   加密破坏并从现有应用程序中删除。
   此版本的标准仅向后支持MD2和MD5-
   兼容性原因。

   SHA-1的密码分析也取得了进步。
   特别是，王等人的结果。[ SHA1CRYPT ]（其中包含
   已由M. Cochran在其分析中独立验证[ COCHRAN ]）
   关于使用微分路径在SHA-1中查找冲突的说明，
   得出的结论是SHA-1哈希算法的安全强度为
   大大减少。但是，这种减少并不明显
   足以保证从现有应用程序中删除SHA-1，
   但建议仅将其用法用于向后兼容
   原因。

   为解决这些问题，仅SHA-224，SHA-256，SHA-384，SHA-512，
   建议将SHA-512 / 224和SHA-512 / 256用于新应用程序。
   到目前为止，针对这些哈希的最佳（已知）冲突攻击
   功能是复杂度为2L / 2的通用攻击，其中L是
   哈希输出的位长。对于此中的签名方案
   文档中，碰撞攻击很容易翻译成签名
   伪造的。因此，值L / 2应该至少等于
   签名方案所需的安全级别（以安全为单位）
   B位的级别表示最佳攻击的复杂度为2B）。这
   同样的经验法则可以应用于RSAES-OAEP；推荐
   种子的位长（等于
   哈希输出）是所需安全级别（以位为单位）的两倍。

B.2。遮罩生成功能

   掩码生成函数采用长度可变的八位字节串
   并以所需的输出长度作为输入，并输出一个八位字节串
   所需的长度。长度可能有所限制
   输入和输出八位位组字符串，但是这样的界限通常非常大
   大的。遮罩生成函数是确定性的；八位字节串
   输出完全由输入八位位组字符串决定。这
   掩码生成函数的输出应为伪随机：给定
   输出的一部分而不是输入的一部分，应该是不可行的
   预测输出的另一部分。可证明的安全性
   RSAES-OAEP和RSASSA-PSS依赖于输出的随机性
   掩码生成函数的功能，而后者又依赖于随机
   基础哈希的性质。

   此处提供了一个遮罩生成功能：MGF1，它基于一个
   哈希函数。MGF1与遮罩生成功能一致
   在IEEE 1363 [ IEEE1363 ]和ANSI X9.44 [ ANSIX944 ]中定义。未来
   本文档的版本可能会定义其他遮罩生成功能。




Moriarty等。信息性[Page 66]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


B.2.1。MGF1

   MGF1是基于哈希函数的掩码生成函数。

   MGF1（mgfSeed，maskLen）

   选项：

      散列散列函数（hLen表示字节的长度，以八位字节为单位）
               哈希函数输出）

   输入：

      从其生成掩码的mgfSeed种子，一个八位位组字符串
      maskLen掩码的预期长度（以八位字节为单位），最多2 ^ 32 hLen

   输出：

      mask mask，长度为maskLen的八位字节串

   错误：“遮罩时间过长”

   脚步：

   1.如果maskLen> 2 ^ 32 hLen，则输出“ mask too long”并停止。

   2.令T为空的八位位组字符串。

   3.对于从0到\ ceil（maskLen / hLen）-1的计数器，执行
       下列的：

       A.将计数器转换为长度为4个八位位组的八位位组字符串C（请参见
           第4.1节）：

              C ＝ I2OSP（计数器4）。

       B.将种子mgfSeed和C的哈希值连接到八位位组
           字符串T：

              T = T || 哈希（mgfSeed || C）。

   4.输出T的前maskLen个八位字节作为八位字节串掩码。

   对象标识符id-mgf1标识MGF1掩码生成
   功能：

      id-mgf1对象标识符:: = {pkcs-1 8}




Moriarty等。信息性[页67]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   与此OID关联的parameter字段，类型为value
   AlgorithmIdentifier的值应为hashAlgorithm类型，
   标识MGF1所基于的哈希函数。

附录C。ASN.1模块

   -PKCS＃1 v2.2 ASN.1模块
   -2012年10月27日修订

   -已检查该模块是否符合
   -OSS ASN.1工具的ASN.1标准

   PKCS-1 {
       iso（1）成员-主体（2）us（840）rsadsi（113549）pkcs（1）pkcs-1（1）
       模块（0）pkcs-1（1）
   }

   定义显式标记:: =

   开始

   -全部导出
   -导出此模块中定义的所有类型和值以供使用
   -在其他ASN.1模块中。

   进口商品

   id-sha224，id-sha256，id-sha384，id-sha512，id-sha512-224，
   id-sha512-256
       来自NIST-SHA2 {
           联合iso-itu-t（2）国家（16）美国（840）组织（1）
           gov（101）csor（3）nistalgorithm（4）hashAlgs（2）
       };

   -===========================
   -基本对象标识符
   -===========================

   -十六进制的DER编码为：
   -（0x）06 08
   -2A 86 48 86 F7 0D 01 01
   --
   pkcs-1对象标识符:: = {
       iso（1）成员-body（2）us（840）rsadsi（113549）pkcs（1）1
   }

   --
   -当在AlgorithmIdentifier中使用rsaEncryption时，



Moriarty等。信息性[Page 68]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   -参数必须存在且必须为NULL。
   --
   rsaEncryption对象标识符:: = {pkcs-1 1}

   --
   -当在AlgorithmIdentifier中使用id-RSAES-OAEP时，
   -参数必须存在，并且必须是RSAES-OAEP-params。
   --
   id-RSAES-OAEP对象标识符:: = {pkcs-1 7}

   --
   -当在AlgorithmIdentifier中使用id-pSpecified时，
   -参数必须是OCTET STRING。
   --
   id-p指定的对象标识符:: = {pkcs-1 9}

   --
   -当在AlgorithmIdentifier中使用id-RSASSA-PSS时，
   -参数必须存在，并且必须是RSASSA-PSS-params。
   --
   id-RSASSA-PSS对象标识符:: = {pkcs-1 10}

   --
   -当在AlgorithmIdentifier中使用以下OID时，
   -参数必须存在且必须为NULL。
   --
   md2WithRSAEncryption对象标识符:: = {pkcs-1 2}
   md5WithRSAEncryption对象标识符:: = {pkcs-1 4}
   sha1WithRSAEncryption对象标识符:: = {pkcs-1 5}
   sha224WithRSAEncryption对象标识符:: = {pkcs-1 14}
   sha256WithRSAEncryption对象标识符:: = {pkcs-1 11}
   sha384WithRSAEncryption对象标识符:: = {pkcs-1 12}
   sha512WithRSAEncryption对象标识符:: = {pkcs-1 13}
   sha512-224WithRSAEncryption对象标识符:: = {pkcs-1 15}
   sha512-256WithRSAEncryption对象标识符:: = {pkcs-1 16}

   --
   -这个OID实际上属于带有secsig OID的模块。
   --
   id-sha1对象标识符:: = {
       iso（1）识别组织（3）oiw（14）secsig（3）算法（2）
       26
   }

   --
   -MD2和MD5的OID，仅在EMSA-PKCS1-v1_5中允许。
   --
   id-md2对象标识符:: = {



Moriarty等。信息性[Page 69]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


       iso（1）成员-body（2）us（840）rsadsi（113549）摘要算法（2）2
   }

   id-md5对象标识符:: = {
       iso（1）成员-body（2）us（840）rsadsi（113549）digestAlgorithm（2）5
   }

   --
   -在AlgorithmIdentifier中使用id-mgf1时，参数
   -必须存在且必须是HashAlgorithm，例如sha1。
   --
   id-mgf1对象标识符:: = {pkcs-1 8}

   -================
   -有用的类型
   -================

   算法标识符::: CLASS {
       ＆id对象标识符唯一，
       ＆Type可选
   }
       使用语法{OID＆id [PARAMETERS＆Type]}

   -注意：以下定义中的参数InfoObjectSet
   -允许为集合指定不同的信息对象集合
   -的算法，例如：
   -DigestAlgorithms算法标识符:: = {
   -{OID id-md2参数为空} |
   -{OID id-md5参数为空} |
   -{OID id-sha1参数NULL}
   -}
   --

   AlgorithmIdentifier {ALGORITHM-IDENTIFIER：InfoObjectSet} :: =
       顺序 {
         算法
             ALGORITHM-IDENTIFIER。＆id（{InfoObjectSet}），
         参数
             ALGORITHM-IDENTIFIER。＆Type（{InfoObjectSet} {@。algorithm}）
               可选的
   }

   -==============
   -算法
   -==============

   --
   -允许的EME-OAEP和EMSA-PSS摘要算法。



Moriarty等。信息性[页70]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   --
   OAEP-PSSDigestAlgorithms算法标识符:: = {
       {OID id-sha1参数为空} |
       {OID id-sha224参数NULL} |
       {OID id-sha256参数NULL} |
       {OID id-sha384参数NULL} |
       {OID id-sha512参数NULL} |
       {OID id-sha512-224参数NULL} |
       {OID id-sha512-256参数NULL}，
       ...-允许将来扩展-
   }

   --
   -允许使用EMSA-PKCS1-v1_5摘要算法。
   --
   PKCS1-v1-5DigestAlgorithms算法标识符:: = {
       {OID id-md2参数为空} |
       {OID id-md5参数为空} |
       {OID id-sha1参数为空} |
       {OID id-sha224参数NULL} |
       {OID id-sha256参数NULL} |
       {OID id-sha384参数NULL} |
       {OID id-sha512参数NULL} |
       {OID id-sha512-224参数NULL} |
       {OID id-sha512-256参数NULL}
   }

   -在AlgorithmIdentifier中使用id-md2和id-md5时，
   -参数字段应具有NULL类型的值。

   -当id-sha1，id-sha224，id-sha256，id-sha384，id-sha512，
   -id-sha512-224和id-sha512-256用于
   -AlgorithmIdentifier，参数（可选）应为
   -省略，但如果存在，则它们的值将为NULL。
   -但是，实现必须接受AlgorithmIdentifier值
   -不带参数和带NULL参数。

   -例外：在EMSA-PKCS1-v1_5中格式化DigestInfoValue时
   -（请参阅第9.2节），与id-sha1关联的参数字段，
   -id-sha224，id-sha256，id-sha384，id-sha512，id-sha512-224和
   -id-sha512-256应具有NULL类型的值。这是为了
   -保持与现有实现以及与
   -已经为EMSA-PKCS1-v1_5发布的数字信息值，
   -也反映在IEEE 1363a中。

   sha1 HashAlgorithm :: = {
       算法id-sha1，
       参数SHA1Parameters：NULL



Moriarty等。信息性[页71]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   }

   HashAlgorithm :: = AlgorithmIdentifier {{OAEP-PSSDigestAlgorithms}}

   SHA1Parameters :: =空

   --
   -允许的遮罩生成功能算法。
   -如果标识符为id-mgf1，则参数为HashAlgorithm。
   --
   PKCS1MGF算法算法标识符:: = {
       {OID id-mgf1参数HashAlgorithm}，
       ...-允许将来扩展-
   }

   --
   -id-RSAES-OAEP.maskGenAlgorithm和的默认算法标识符
   -id-RSASSA-PSS.maskGenAlgorithm。
   --
   mgf1SHA1 MaskGenAlgorithm :: = {
       算法id-mgf1，
       参数HashAlgorithm：sha1
   }

   MaskGenAlgorithm :: = AlgorithmIdentifier {{PKCS1MGFAlgorithms}}

   --
   -允许的pSourceAlgorithm算法。
   --
   PKCS1PSourceAlgorithms算法标识符:: = {
       {OID id-pSpecified PARAMETERS EncodingParameters}，
       ...-允许将来扩展-
   }

   EncodingParameters :: = OCTET STRING（SIZE（0..MAX））

   --
   -此标识符表示标签L是一个空字符串，因此
   -空字符串的摘要出现在RSA块中
   -遮罩。
   --

   pSpecifiedEmpty PSourceAlgorithm :: = {
       算法id-pSpecified，
       参数EncodingParameters：emptyString
   }

   PSourceAlgorithm :: = AlgorithmIdentifier {{PKCS1PSourceAlgorithms}}



Moriarty等。信息性[页72]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   emptyString EncodingParameters :: =''H

   --
   -PKCS＃1 OID的类型标识符定义。
   --
   PKCS1算法算法标识符:: = {
       {OID rsaEncryption参数为空} |
       {OID md2WithRSAEncryption参数为空} |
       {OID md5WithRSAEncryption参数为空} |
       {OID sha1WithRSAEncryption参数NULL} |
       {OID sha224WithRSAEncryption参数为空} |
       {OID sha256WithRSAEncryption参数NULL} |
       {OID sha384WithRSAEncryption参数为空} |
       {OID sha512WithRSAEncryption参数NULL} |
       {OID sha512-224WithRSAEncryption参数为空} |
       {OID sha512-256WithRSAEncryption参数NULL} |
       {OID id-RSAES-OAEP参数RSAES-OAEP参数} |
       PKCS1PSourceAlgorithms |
       {OID id-RSASSA-PSS参数RSASSA-PSS参数}，
       ...-允许将来扩展-
   }

   -===================
   -主要结构
   -===================

   RSAPublicKey :: = SEQUENCE {
       模数INTEGER，-n
       publicExponent整数-e
   }

   --
   -带有CRT信息的RSA私钥表示
   -  算法。
   --
   RSAPrivateKey :: = SEQUENCE {
       版本Version，
       模数INTEGER，-n
       publicExponent整数--e
       privateExponent整数--d
       prime1 INTEGER，-p
       prime2 INTEGER，-q
       指数1整数--d mod（p-1）
       exponent2整数，-d mod（q-1）
       系数INTEGER，-（q的倒数）mod p
       otherPrimeInfos OtherPrimeInfos可选
   }




Moriarty等。信息性[页73]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   版本:: = INTEGER {二素（0），multi（1）}
       （受约束
         {-版本必须
    如果otherPrimeInfos存在，则为多-}）

   OtherPrimeInfos :: = OtherPrimeInfo的SEQUENCE SIZE（1..MAX）


   OtherPrimeInfo :: = SEQUENCE {
       原始整数--ri
       指数INTEGER，-di
       系数INTEGER-ti
   }

   --
   -id-RSAES-OAEP的AlgorithmIdentifier.parameters。
   -请注意，此序列中的标记是显式的。
   --
   RSAES-OAEP-params :: = SEQUENCE {
       hashAlgorithm [0] HashAlgorithm默认值sha1，
       maskGenAlgorithm [1] MaskGenAlgorithm DEFAULT mgf1SHA1，
       pSourceAlgorithm [2] PSourceAlgorithm缺省pSpecifiedEmpty
   }

   --
   -默认RSAES-OAEP算法标识符的标识符。
   -DER编码为十六进制：
   -（0x）30 0D
   -06 09
   -2A 86 48 86 F7 0D 01 01 07
   -30 00
   -请注意，默认值的DER编码为“空”。
   --

   rSAES-OAEP-默认标识符RSAES-AlgorithmIdentifier :: = {
       算法ID-RSAES-OAEP，
       参数RSAES-OAEP-params：{
           hashAlgorithm sha1，
           maskGenAlgorithm mgf1SHA1，
           pSourceAlgorithm pSpecifiedEmpty
       }
   }

   RSAES-AlgorithmIdentifier :: = AlgorithmIdentifier {
       {PKCS1Algorithms}
   }

   --



Moriarty等。信息性[Page 74]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   -id-RSASSA-PSS的AlgorithmIdentifier.parameters。
   -请注意，此序列中的标记是显式的。
   --
   RSASSA-PSS-params :: = SEQUENCE {
       hashAlgorithm [0] HashAlgorithm默认值sha1，
       maskGenAlgorithm [1] MaskGenAlgorithm DEFAULT mgf1SHA1，
       saltLength [2]整数默认值20，
       trailerField [3] TrailerField默认值trailerFieldBC
   }

   TrailerField :: =整数{trailerFieldBC（1）}

   --
   -默认RSASSA-PSS算法标识符的标识符
   -DER编码为十六进制：
   -（0x）30 0D
   -06 09
   -2A 86 48 86 F7 0D 01 01 0A
   -30 00
   -请注意，默认值的DER编码为“空”。
   --
   rSASSA-PSS-默认标识符RSASSA-AlgorithmIdentifier :: = {
       算法ID-RSASSA-PSS，
       参数RSASSA-PSS-params：{
           hashAlgorithm sha1，
           maskGenAlgorithm mgf1SHA1，
           saltLength 20，
           trailerField trailerFieldBC
       }
   }

   RSASSA-AlgorithmIdentifier :: = AlgorithmIdentifier {
       {PKCS1Algorithms}
   }

   --
   -EMSA-PKCS1-v1_5哈希标识符的语法。
   --
   DigestInfo :: = SEQUENCE {
       摘要算法DigestAlgorithm，
       摘要OCTET STRING
   }

   DigestAlgorithm ::: AlgorithmIdentifier {
       {PKCS1-v1-5DigestAlgorithms}
   }

   结尾



Moriarty等。信息性[第75页]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


附录d。PKCS＃1的修订历史

   1.0-1.5版：

      已将1.0-1.3版分发给RSA Data中的参与者
      Security，Inc.的公开密钥密码学标准会议在
      1991年2月和3月。

      1.4版是1991年6月3日首次发布的
      PKCS。1.4版已发布为NIST / OSI实施者
      研讨会文件SEC-SIG-91-18。

      1.5版纳入了一些编辑上的更改，包括
      更新参考文献并添加修订历史记录。
      进行了以下实质性更改：

      *  第10节：“带有RSA的MD4”签名和验证过程
         添加。

      *  第11节：添加了md4WithRSAEncryption对象标识符。

      1.5版被重新发布为[ RFC2313 ]（后来
      被[ RFC2437 ]废弃）。

   2.0版：

      2.0版在内容方面纳入了重大的编辑更改
      文档结构并介绍了RSAES-OAEP加密
      方案。此版本继续支持加密和
      1.5版本中的签名过程，尽管使用了哈希算法
      由于密码分析技术的进步，不再允许使用MD4
      中间岁月。版本2.0重新发布为[ RFC2437 ]
      （后来被[ RFC3447 ]淘汰）。

   版本2.1：

      2.1版引入了多素RSA和RSASSA-PSS
      带附录的签名方案以及一些社论
      改进。此版本继续支持以下版本中的方案
      版本2.0。版本2.1重新发布为[ RFC3447 ]。











Moriarty等。信息性[Page 76]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


   2.2版：

      2.2版将允许的哈希算法列表更新为
      将它们与FIPS 180-4 [ SHS ]对齐，因此添加了SHA-224，
      SHA-512 / 224和SHA-512 / 256。以下实质性变化
      被制成：

      * sha224WithRSAEncryption的对象标识符，
         sha512-224WithRSAEncryption和sha512-256WithRSAEncryption
         添加。

      *此版本继续支持2.1版中的方案。

附录E。关于PKCS

   公钥密码标准是由
   RSA实验室与安全系统开发人员合作
   在全球范围内，以加快公共场所的部署，
   密钥密码学。通过会议于1991年首次出版
   与一小批采用公钥技术的人一起，
   PKCS文件已被广泛引用和实施。
   PKCS系列的内容已成为许多正式内容的一部分
   和事实上的标准，包括ANSI X9和IEEE P1363文档，
   PKIX，安全电子交易（SET），S / MIME，SSL / TLS和
   无线应用协议（WAP）/ WAP传输层安全性
   （WTLS）。

   大多数PKCS文件的进一步开发都是通过IETF进行的。
   欢迎提出改进建议。






















Moriarty等。信息性[Page 77]
 
RFC 8017                       PKCS＃1 v2.2 2016年11月


致谢

   本文档基于RSA实验室的贡献，
   RSA Security Inc.研究中心

作者的地址

   凯瑟琳·M·莫里亚蒂（编辑）
   EMC公司
   南街176号
   马萨诸塞州霍普金顿01748
   美国

   电子邮件：kathleen.moriarty@emc.com


   伯特·卡利斯基（Burt Kaliski）
   威瑞信
   12061 Bluemont Way
   弗吉尼亚州雷斯顿20190
   美国

   电子邮件：bkaliski@verisign.com
   URI：http：    //verisignlabs.com


   雅各布·琼森（Jakob Jonsson）
   子集AB
   Munkbrogtan 4
   斯德哥尔摩SE-11127
   瑞典

   电话：+46 8 428 687 43
   电子邮件：jakob.jonsson@subset.se

   安德烈亚斯·鲁施（Andreas Rusch）
   RSA
   皇后街345号
   布里斯班，昆士兰州4000
   澳大利亚

   电子邮件：andreas.rusch@rsa.com